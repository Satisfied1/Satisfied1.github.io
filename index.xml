<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>前端天地</title>
    <link>https://Satisfied1.github.io/index.xml</link>
    <description>Recent content on 前端天地</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Released under the MIT license</copyright>
    <lastBuildDate>Thu, 08 Dec 2016 11:19:29 +0800</lastBuildDate>
    <atom:link href="https://Satisfied1.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Web应用的组件化 2</title>
      <link>https://satisfied1.github.io/post/Web%E5%BA%94%E7%94%A8%E7%9A%84%E7%BB%84%E4%BB%B6%E5%8C%96-2/</link>
      <pubDate>Thu, 08 Dec 2016 11:19:29 +0800</pubDate>
      
      <guid>https://satisfied1.github.io/post/Web%E5%BA%94%E7%94%A8%E7%9A%84%E7%BB%84%E4%BB%B6%E5%8C%96-2/</guid>
      <description>&lt;p&gt;Web应用的组件化（二）&lt;/p&gt;

&lt;p&gt;管控平台&lt;/p&gt;

&lt;p&gt;在上一篇中我们提到了组件化的大致思路，这一篇主要讲述在这么做之后，我们需要哪些外围手段去管控整个开发过程。从各种角度看，面对较大规模前端开发团队，都有必要建立这么一个开发阶段的协作平台。&lt;/p&gt;

&lt;p&gt;在这个平台上，我们要做哪些事情呢？
#1. HTML片段&lt;/p&gt;

&lt;p&gt;我们为什么要管理HTML片段？因为有界面要用它们，当这些片段多了之后，需要有个地方来管理起来，可以检索、预览它们，还能看到大致描述。&lt;/p&gt;

&lt;p&gt;这应该是整个环节中一个相对很简单的东西，照理说，有目录结构，然后剩下的就是单个的HTML片段文件了，这就可以解决存储和检索的问题了，但我们还要考虑更多。&lt;/p&gt;

&lt;p&gt;已有的HTML片段，如何被使用呢？这肯定是一种类似include的方式，通过某种特殊标签（不管是前端还是后端的方式）把这些片段引用进来，这时候就有了第一个问题：&lt;/p&gt;

&lt;p&gt;假设有界面A和界面B同时引用了片段C，在某个开发人员修改片段C内容的时候，他如何得知将会影响到界面A和B呢？一个比较勉强的方式是全项目查找，但这在很多情况下是不够的。&lt;/p&gt;

&lt;p&gt;如果我们的HTML片段是作为独立的公共库存在的，它已经不能通过项目内查找去解决这一问题了，因为不管A还是B，只要他不处于片段C的项目空间，就无从追寻。&lt;/p&gt;

&lt;p&gt;这时候很多人会问两个问题：&lt;/p&gt;

&lt;p&gt;跨项目的界面片段重用，意义在哪里？&lt;/p&gt;

&lt;p&gt;如果我们的产品是针对一个小领域，它的复杂度根本不需要划分多个项目部分来协作完成。设想场景是面对很大的行业，各项目都是子产品，将来可能是其中若干个联合部署，这时候，保持其中的一致性是非常重要的。比如我们有个基本配置界面，在多个子产品中都要用，如果各自开发一个，其操作风格很可能就是不一致的，给人的印象就是不专业。所以会需要把常见的界面片段都归集起来，供业务方挑选使用。&lt;/p&gt;

&lt;p&gt;修改C，只提供说明，但是不通知A和B，不实时更新他们的版本，然后自行决定怎样升级，如何？&lt;/p&gt;

&lt;p&gt;这会有一个问题，每次有小功能升级的时候，代码是最容易同步合并的，所以才会有“持续集成”这个概念，如果是一直伴随升级，总要比隔一个大阶段才升级好，升级成本应尽量分摊到平时，就像农妇养小猪，小猪每天长一点，每天都抱来抱去，不觉得吃力，即使长大了也还能抱得动。&lt;/p&gt;

&lt;p&gt;现在问题就很明确了，一定要有一种方式来把这个依赖关系管理起来，很显然，已有的版本库是肯定管不了这些的，所以只能在外围做一些处理。&lt;/p&gt;

&lt;p&gt;我们建立一个管理平台，除了管理实体文件的版本，还管它们之间的关系。具体这个关系如何收集整理，有两种方式：手动配置，代码分析。&lt;/p&gt;

&lt;p&gt;手动配置是比较土的方式，开发人员每提交一个文件，就去这系统上手动配置它的依赖关系。代码分析的话，要在每次提交文件的时候解析文件的包含规则，找出确切的文件。这两者各有利弊，前者比较笨，但容易做，后者对代码格式的要求比较高，要考虑的情况较多。&lt;/p&gt;

&lt;p&gt;我们的界面往往不是那么简单，HTML片段也可能有层次的，举例来说：&lt;/p&gt;

&lt;p&gt;界面A里面包含了片段B，但是片段B自身又包含了片段C，所以这个依赖关系也是有层级的，需要在设计的时候一并考虑。
#2. JavaScript模块&lt;/p&gt;

&lt;p&gt;JavaScript代码的管理，比HTML片段的状况好一些，因为业界很多这方面的解决方案。但它们还是没有解决当依赖项产生变更的时候反向通知的问题。&lt;/p&gt;

&lt;p&gt;所以我们还是得像HTML片段一样，把它们的依赖关系都管理到平台里。于是，每个JavaScript模块都显式配置了自己所依赖的其他模块，通过这种单向关系，形成了一套完整的视图。&lt;/p&gt;

&lt;p&gt;在JavaScript模块的代码实现中，我们是不提倡直接写依赖关系的。很多通用规范，比如AMD，往往建议我们这样写模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define([&#39;dep1&#39;, &#39;dep2&#39;], function (dep1, dep2) {
    var moduleA = function () {};
    return moduleA;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但我们的系统是面向行业的，比这种通用解决方案要苛刻一些。比如说，如果有一天重构代码，JavaScript模块们调整了目录或者名字，这么写的就痛苦了，他必须把所有影响到的都去调整一遍，这是要搜索替换的。况且，就像上面HTML模板的部分提到的，影响了处于其他项目中依赖它的代码，缺少合适的方式去通知他们修改。&lt;/p&gt;

&lt;p&gt;所以我们期望的是，在每个编写的JavaScript模块中只存放具体实现，而把依赖关系放在我们的平台上管理，这样，即使当前模块作了改名之类的重构处理，处于外部项目中依赖它的那些代码也不必修改，下一次版本发布的生成过程会自动把这些事情干掉。&lt;/p&gt;

&lt;p&gt;对应到上面的这段代码，我们需要开发人员做的只是其中的实现，也就是moduleA的那个部分，外面这些依赖的壳子，是会在发布阶段根据已配置的依赖关系自动生成的。&lt;/p&gt;

&lt;p&gt;如果需要，JavaScript模块还可以细分，比如类似Angular里面那样，把factory，controller和directive分离出来，这会对后续有些处理提供方便。&lt;/p&gt;

&lt;p&gt;现在我们有必要讨论一下模块的粒度了，我们这里提到的都是基本的粒度，每个JavaScript模块中存放的应该只有一个很具体东西的实现。那么，有个问题，在我们发布的时候，是不是就按照这个粒度发布出去呢？&lt;/p&gt;

&lt;p&gt;很显然不行，如果这么做，很可能会出现复杂界面一次要用10多个HTTP请求才能加载完它所需要的所有JavaScript代码的情况，所以需要做一些合并。&lt;/p&gt;

&lt;p&gt;那么，合并的策略是什么？在我们这个平台上，开发人员又是要怎样定义这个合并关系的呢？我们需要在模块之上定义一个更大粒度的组织方式，这个方式与模块的关系，就好比Java里面，jar文件与class的关系。如果开发人员不显式配置，也可以通过全局策略，比如按最下层目录来合并。&lt;/p&gt;

&lt;p&gt;这个时候，在实际使用这些代码的时候，需要带两个配置信息过去，一个是要动态载入的JavaScript文件（合并之后的），二是每个JavaScript文件中包含的原始模块。
#3. 单元测试&lt;/p&gt;

&lt;p&gt;如果JavaScript模块都已经被良好有序管理起来，就可以为它们考虑单元测试的事情了。单元测试对于提高基础单元的可靠度，是有非常重要意义的。&lt;/p&gt;

&lt;p&gt;在我们这个平台里，可以把单元测试跟JavaScript模块关联起来，每个JavaScript模块可以挂一组单元测试代码，这些代码可以在线编写，在线运行。&lt;/p&gt;

&lt;p&gt;单元测试的本质就是编写模拟代码来调用已有模块，考虑到我们的模块是JavaScript，所以很多思路都倾向于在浏览器端执行它们，对于单个模块的单元测试，这不是个问题。&lt;/p&gt;

&lt;p&gt;如果要批量执行整个系统的单元测试，那就不一样了。把JavaScript代码先加载到浏览器中，然后再执行，很多时候并不需要这么复杂。我们完全可以在服务端把它们做了。&lt;/p&gt;

&lt;p&gt;借助Node.js的能力，我们可以在服务端执行JavaScript代码，也就意味着能够把绝大多数JavaScript模块的单元测试在服务端就执行掉。当然，我们为此可能要多做不少事情，比如说，有些库需要移植一份node版的，常见的有AJAX调用等等。&lt;/p&gt;

&lt;p&gt;注意了，能够在服务端做JavaScript单元测试是有先决条件的，代码的分层必须很良好，除了视图层，其他任何层面都不能操作DOM。所以我们这里主要测试的也正是除了视图层之外的所有JavaScript业务逻辑。至于视图层怎么办？这个真的很难解决，这世界上不是所有东西都能自动做的，只能先把可做的做了，以后再来考虑这些。
#4. 文档和示例管理&lt;/p&gt;

&lt;p&gt;4.1. 文档&lt;/p&gt;

&lt;p&gt;现在我们有HTML片段和JavaScript模块了，需要给它们多一些描述信息。简单描述显然是不够的，我们还要详细文档。&lt;/p&gt;

&lt;p&gt;这种详细文档可以通过某种方式生成，也可以由开发人员手动编写。与传统的离线文档不同，在线的文档更实时，并且，每当一个开发人员变更了他的文档之后，不需要经过全量构建，访问者可以实时访问到他的最新版本。&lt;/p&gt;

&lt;p&gt;熟悉GitHub的朋友们可能早已习惯这种方式，在项目库里面存在一些以md格式结尾的文本文件，使用markdown语法来编写一些说明文档。&lt;/p&gt;

&lt;p&gt;毫无疑问，这类格式很适合在线协作，所以我们也会在平台上集成这么一种编写文档的方式，无论是针对HTML模板还是JavaScript模块，或者是其他什么类型，甚至还可以用来当博客，就像月影同学的gitpress平台，能直接从GitHub上拉取文本或者HTML文件形成博客。&lt;/p&gt;

&lt;p&gt;文档除了以集成的形式浏览之外，应当也可以以单独链接的方式发出去，这时候用户就可以像看一个新闻网页一样去浏览。如果再进一步做下去，还可以做电子书的生成，提供打包的离线文档。&lt;/p&gt;

&lt;p&gt;4.2. 示例&lt;/p&gt;

&lt;p&gt;在编写代码文档的过程中，可能免不了要插入示例，示例有两种形态，一种是纯文本，类似gist这样，一种是可在线运行，类似jsfiddle和jsbin这样。&lt;/p&gt;

&lt;p&gt;这两种都有各自的优点，所以可以都做，示例的存放可以与文档类似，也应当能通过一个链接独立运行。&lt;/p&gt;

&lt;p&gt;4.3. 幻灯片&lt;/p&gt;

&lt;p&gt;有时候我们看到一些在线的幻灯片，觉得效果很帅，比如reveal.js，我们的开发人员有时候作代码分析或者走查的时候也不免要写一些演示，如果能把这些东西也随项目管理起来，能在线查看，会是很不错的一件事。所以我们也可以考虑给它们加个存储界面，甚至做个简易的在线编写器。
#5. 项目与目录管理&lt;/p&gt;

&lt;p&gt;说到现在，我们似乎还遗漏了一点什么。那就是以上提到的这些东西，以什么为组织单位来存储？&lt;/p&gt;

&lt;p&gt;考虑到我们的这个平台是要管理一整个大产品的全部前端内容的，它里面应该分了很多项目，对应到子产品上，这么一来，很自然地，项目就成了第一级组织单位。项目之下，没有悬念地，只有目录了。&lt;/p&gt;

&lt;p&gt;对于一个项目而言，它有哪些要做的事情呢？首先要能配置其实体存储位置。前面提到的这么多代码、文档之类，最终都是要实体存储的，怎么存？我们当然可以自己搞一套，在文件系统上做起来，但是还要考虑它们的版本管理，非常麻烦，所以不如直接对接某个版本库，调用它的接口去存取文件，这里配置的就是版本库的路径。&lt;/p&gt;

&lt;p&gt;其次，要考虑从已有项目复制，类似GitHub里面的fork功能，不过内部处理机制可以略有不同，fork的项目默认未必要有实体文件，只有当产生了修改或者新增操作的时候才创建，剩下的还引用原来的就可以了。我们这里的项目复制功能是为项目化版本而考虑的，经常出现一个产品版本支持多个客户项目的情况，所以可能会用得着这个特性。&lt;/p&gt;

&lt;p&gt;然后，也要考虑项目的依赖关系。依赖一个项目，意思是需要用到它里面的组件，所以实质是组件的依赖。提供项目依赖这个视图，只是为了未来变更的一些考虑。
#6. 评论管理&lt;/p&gt;

&lt;p&gt;之前提到，我们整个平台的目的是为了提高大型前端团队的协作能力，协作是离不开交流的。上述的任何功能，都应当带有交流沟通的能力。&lt;/p&gt;

&lt;p&gt;比如说，如果开发人员A使用了其他人写的一个代码组件a，对其中一些细节有疑问，他应当可以对它进行评论。在他评论的时候，任何参与维护过这个组件的人员都能收到一个提醒，这时候他可以选择过来看看，回复这个疑问。同理，在文档、示例下也可以如此操作。&lt;/p&gt;

&lt;p&gt;在互联网上有这类产品，用于在任意URL下挂接评论交流系统，比较有名的就是Disqus，我们可以看到很多网站下面挂着它，用于做交流评论，这样用户可以用一个账号在多个网站之间交流。国内也有同类的，比如多说，能够用微博、QQ等账号登录进行交流。&lt;/p&gt;

&lt;p&gt;从我们这个平台本身看，如果是部署在企业内部作流程提升，引入外部评论系统的可能性就比较小了。因为在企业内部用，一定是希望这个员工的账号信息跟工号挂钩，也能够跟版本服务器账号等模块作集成，权限也便于控制。&lt;/p&gt;

&lt;p&gt;从另外一个角度讲，某个人员登录这个系统的时候，他可能收到很多消息，来自不同的代码或文档位置，挨个点过去回复也有些麻烦，我们应当给他提供一个全局视图，让他能在一个统一的界面把这些问题都答复掉，如果他需要的话，也是可以点进去到实际的位置。
#7. 用户和权限控制&lt;/p&gt;

&lt;p&gt;从以上部分我们已经看到，这个系统是一个比较复杂的开发过程管控平台。这样的话，每个使用的人就应当可以登录，然后分配不同的权限等级。&lt;/p&gt;

&lt;p&gt;未登录用户应当有一些东西的查看权限，但是不能发表评论。已登录的用户根据权限级别，可以控制能否创建、修改项目，创建、修改目录，代码，单元测试，文档等。
#8. 国际化字符串管理&lt;/p&gt;

&lt;p&gt;一个跨语言区域的Web应用不可避免要跟国际化打交道，这个事情通常是在服务端做，比如通过在界面代码中嵌入类似&amp;lt;% =getRes(key, lan) %&amp;gt;这样的代码，去获取相应的字符串，替换到界面里来。&lt;/p&gt;

&lt;p&gt;这个事情是要占用应用服务器资源的，而且国际化本身其实是一个在运行之前就已经确定的事，完全可以把这个过程放在发布阶段就做掉。比如说，我们给每种语言预先就把代码生成多份，只是部署在一起，根据需要的情况来动态加载特定的那一份。&lt;/p&gt;

&lt;p&gt;有不少客户端的国际化方案，是把资源文件拆细，以页面为单位存储，但这其实是不太合理的。第一个原因就是在Web2.0时代，“页面”这个概念本身就已经弱化了，到了单页应用里，整个应用都只是一个页面，这个时候，资源文件以什么粒度来组织呢？&lt;/p&gt;

&lt;p&gt;我们提到过，采用MV*框架去做Web应用的架构，有一个目标是做组件化。组件化的意图就是某个组件可以尽可能随心所欲地放在需要的地方用。如果把资源文件的粒度弄小到对应HTML片段和JavaScript模块这一级，灵活性倒是有了，带来的问题就是管理成本增大。&lt;/p&gt;

&lt;p&gt;做一个行业应用，最重要的就是业务一致性，这包括逻辑的一致性，也包括了术语的一致性。某一个词，可能在多个资源文件中都出现，这就增加了不一致的可能性。&lt;/p&gt;

&lt;p&gt;所以，应当有一个统一的术语管理平台，一切界面上出现的文字或者提示，都必须来自这个平台。
#9. 静态资源的管理&lt;/p&gt;

&lt;p&gt;在发布系统的时候，除了需要发布代码，还需要发布图片等静态资源，这些东西也应当被管理起来。&lt;/p&gt;

&lt;p&gt;静态资源在两种情况下可用：随产品发布，在本平台被引用。比如说有一个图片，在这个平台上作了管理，它可以被配置到某个项目上，在发布的时候导出。这个图片还可以被用链接的方式查看或者下载，如果本平台内部的一个文档或者示例要引用它，也是可以的。
#10. 样式与主题管理&lt;/p&gt;

&lt;p&gt;在Web系统里，样式和主题是很重要的一环。样式的管理和发布一直是一个比较复杂的话题，早几年一般都是分块写，然后组合合并，最近这些年有LESS，SASS和Stylus这类技术，解决了编写和发布的分离问题。&lt;/p&gt;

&lt;p&gt;我们看看发布的最大问题是什么？是不同部分的合并。为了追求灵活性，不得不把东西拆得很细，之前HTML片段和JavaScript模块的处理方式都是这样。这么做，我们就需要另外一件事：这些细小的东西，尽可能要覆盖全面。&lt;/p&gt;

&lt;p&gt;对应到CSS里面，我们要做的是把每种在系统中可能出现的元素、类别都作为单独的规则维护起来，生成一个全局的规则列表。不同项目间，实现可以不同，但规则的名字是固定的，定制只允许修改实现，不允许修改规则。如果要新增之前没有的规则，也必须在全局规则列表里先添加，再作实现。&lt;/p&gt;

&lt;p&gt;样式规则被管理之后，可以在界面组件上对它作关联，也可以不做。做的好处是发布的时候能只把用到的那些样式规则生成发布出去，如果能接受每次发布全量CSS，那也无所谓。&lt;/p&gt;

&lt;p&gt;除了规则，也需要考虑一些变量的管理，在CSS中合理使用变量，会大为减轻定制化所导致的工作量。
#11. 一键发布&lt;/p&gt;

&lt;p&gt;我们引入了这么一堆东西，其实是增加了发布的复杂度。为什么呢？&lt;/p&gt;

&lt;p&gt;之前不管HTML、JavaScript还是CSS，都是手写出来，最多经过一个minify的工作，就发布了，整个过程很简单，两句脚本搞定。&lt;/p&gt;

&lt;p&gt;现在可复杂了，先要分析依赖关系，然后提取文件，然后国际化字符串替换，然后合并，然后代码压缩，整个过程很折腾，不给配置管理员一个解释的话，他一定过来砍人。&lt;/p&gt;

&lt;p&gt;我们有个原则：解决问题的过程中，如果引入了新的问题，要求负责解决原问题的人也一起解决掉。现在为了一些意图，增加了版本发布的复杂度，那也要有个办法再把这事摆平，至少不能比原来复杂。&lt;/p&gt;

&lt;p&gt;所以我们就要把这些过程都集成到管控平台里，做一个一键发布的过程，把所有的这些操作都集成起来，配置管理员发布版本的时候只要点一下就可以把所有这些事情做掉。甚至说，这些流程还可以配置，能够加减环节。&lt;/p&gt;

&lt;p&gt;这时候我们做到了跟之前发版本一样方便，能不能多做点什么呢？&lt;/p&gt;

&lt;p&gt;可以把JavaScript单元测试集成到版本发布阶段。因为我们已经把JavaScript按照职责做了分层，并且把UI部分做了隔离，就可以在浏览器之外把这个单元测试做掉，平时提交代码的时候也可以做，最终在版本发布阶段再全量做一下，也是很有意义的。&lt;/p&gt;

&lt;p&gt;代码依赖关系管理的另一个目的是什么呢？是最小化发布，既然我们都管理了文件之间的关系，那么，从根出发，显然是能够得出哪些代码文件在本项目中使用的，就可以每次从我们的全量代码库中取得确切需要的一部分来发布。这也是我们整个管控平台带来的优势。
#12. 小结&lt;/p&gt;

&lt;p&gt;我们这一篇比较复杂，提出了一整套解决大规模前端协作的管控机制。这套理论的本质是在开发和版本发布之间加了一个环节，把Web体系中除了服务之外的一切静态资源都纳入其中，强化了现有主流的一些基于命令行的前端工程化组织模式。&lt;/p&gt;

&lt;p&gt;相比于传统行业，比如汽车制造，我们这个环节相当于生产流水线的设计，其中一些组件的存储就类似仓储机制，发布就类似出厂过程。&lt;/p&gt;

&lt;p&gt;这个平台本身还有不少其他的可做的东西，比如甚至可以在上面做界面的可视化定制等，这些是长远的终极目标，在后面的文章里会谈谈一些考虑。&lt;/p&gt;

&lt;p&gt;后续文章中，我们会展望有了这个平台之后，整个前端的协作流程是怎样的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Web应用的组件化 1</title>
      <link>https://satisfied1.github.io/post/Web%E5%BA%94%E7%94%A8%E7%9A%84%E7%BB%84%E4%BB%B6%E5%8C%96-1/</link>
      <pubDate>Thu, 08 Dec 2016 11:18:08 +0800</pubDate>
      
      <guid>https://satisfied1.github.io/post/Web%E5%BA%94%E7%94%A8%E7%9A%84%E7%BB%84%E4%BB%B6%E5%8C%96-1/</guid>
      <description>&lt;p&gt;Web应用的组件化（一）&lt;/p&gt;

&lt;p&gt;基本思路&lt;/p&gt;

&lt;p&gt;#1. 为什么要做组件化？&lt;/p&gt;

&lt;p&gt;无论前端也好，后端也好，都是整个软件体系的一部分。软件产品也是产品，它的研发过程也必然是有其目的。绝大多数软件产品是追逐利润的，在产品目标确定的情况下，成本有两个途径来优化：减少部署成本，提高开发效率。&lt;/p&gt;

&lt;p&gt;减少部署成本的方面，业界研究得非常多，比如近几年很流行的“去IOE”，就是很典型的，从一些费用较高的高性能产品迁移到开源的易替换的产品集群，又比如使用Linux + Mono来部署.net应用，避开Windows Server的费用。&lt;/p&gt;

&lt;p&gt;提高开发效率这方面，业界研究得更多，主要途径有两点：加快开发速度，减少变更代价。怎样才能加快开发速度呢？如果我们的开发不是重新造轮子，而是每一次做新产品都可以利用已有的东西，那就会好很多。怎样才能减少变更代价呢？如果我们能够理清模块之间的关系，合理分层，每次变更只需要修改其中某个部分，甚至不需要修改代码，仅仅是改变配置就可以，那就更好了。&lt;/p&gt;

&lt;p&gt;我们先不看软件行业，来看一下制造行业，比如汽车制造业，他们是怎么造汽车的呢？造汽车之前，先设计，把整个汽车分解为不同部件，比如轮子，引擎，车门，座椅等等，分别生产，最后再组装，所以它的制造过程可以较快。如果一辆汽车轮胎被扎破了，需要送去维修，维修的人也没有在每个地方都修一下，而是只把轮胎拆下来修修就好了，这个轮胎要是实在坏得厉害，就干脆换上个新的，整个过程不需要很多时间。&lt;/p&gt;

&lt;p&gt;席德梅尔出过一款很不错的游戏，叫做《文明》（Civilization），在第三代里面，有一项科技研究成功之后，会让工人工作效率加倍，这项科技的名字就叫做：可替换部件（Replacement Parts）。所以，软件行业也应当引入可替换的部件，一般称为组件。
#2. 早期的前端怎么做组件化的？&lt;/p&gt;

&lt;p&gt;在服务端，我们有很多组件化的途径，像J2EE的Beans就是一种。组件建造完成之后，需要引入一些机制来让它们可配置，比如说，工作流引擎，规则引擎，这些引擎用配置的方式组织最基础的组件，把它们串联为业务流程。不管使用什么技术、什么语言，服务端的组件化思路基本没有本质差别，大家是有共识的，具体会有服务、流程、规则、模型等几个层次。&lt;/p&gt;

&lt;p&gt;早期展示层基本以静态为主，服务端把界面生成好，浏览器去拿来展示，所以这个时期，有代码控制的东西几乎全在服务端，有分层的，也有不分的。如果做了分层，大致结构就是下图这样：&lt;/p&gt;

&lt;p&gt;web1.0.png&lt;/p&gt;

&lt;p&gt;这个图里，JSP（或者其他什么P，为了举例方便，本文中相关的服务端技术都用Java系的来表示）响应浏览器端的请求，把HTML生成出来，跟相关的JavaScript和CSS一起拿出去展示。注意这里的关键，浏览器端对界面的形态和相关业务逻辑基本都没有控制权，属于别人给什么就展示什么，想要什么要先提申请的尴尬局面。&lt;/p&gt;

&lt;p&gt;这个时期的Web开发，前端的逻辑是基本可忽略的，所以前端组件化方式大同小异，无论是ASP还是JSP还是其他什么P，都可以自定义标签，把HTML代码和行间逻辑打包成一个标签，然后使用者直接放置在想要的地方，就可以了。&lt;/p&gt;

&lt;p&gt;在这一时代，所谓的组件化，基本都是taglib这样的思路，把某一块界面包括它的业务逻辑一起打成一个端到端的组件，整个非常独立，直接一大块从界面到逻辑都有，而且逻辑基本上都是在服务端控制，大致结构如下图所示。&lt;/p&gt;

&lt;p&gt;components in web1.0.png
#3. SPA时代，出现了新问题&lt;/p&gt;

&lt;p&gt;自从Web2.0逐渐流行，Web前端已经不再是纯展示了，它逐渐把以前在C/S里面做的一些东西做到B/S里面来，比如说Google和微软的在线Office，这种复杂度的Web应用如果还用传统那种方式做组件化，很显然是行不通的。&lt;/p&gt;

&lt;p&gt;我们看看之前这种组件化的方式，本质是什么？是展现层跟业务逻辑层的隔离，后端在处理业务逻辑，前端纯展现。如果现在还这么划分，就变成了前端有界面和逻辑，后端也有逻辑，这就比较乱了。我们知道，纯逻辑的分层组件化还是比较容易的，任何逻辑如果跟展现混起来，就比较麻烦了，所以我们要把分层的点往前推，推到也能把单独的展现层剥离出来。&lt;/p&gt;

&lt;p&gt;如下图所示，因为实际上HTML、CSS、JavaScript这些都逐渐静态化，所以不再需要把它们放在应用服务器上了，我们可以把它们放在专门的高性能静态服务器上，再进一步发展，就可以是CDN（Content Delivery Network，内容分发网络）。前端跟后端的通信，基本都是通过AJAX来，也会有一些其他的比如WebSocket之类，总之尽量少刷新了。&lt;/p&gt;

&lt;p&gt;web2.0.png&lt;/p&gt;

&lt;p&gt;在这张图里面可以看到，真正的前端已经形成了，它跟应用服务器之间形成了天然的隔离，所以也能够很独立地进行一些发展演进。&lt;/p&gt;

&lt;p&gt;现在很多Web程序在往SPA（单页面程序，Single Page Application）的方向发展，这类系统通常比较类似传统的C/S程序，交互过程比较复杂，因此它的开发过程也会遇到一些困难。&lt;/p&gt;

&lt;p&gt;那为什么大家要做SPA呢？它有很多明显的好处，最核心的优势就是高效。这个高效体现在两个方面：一是对于用户来说，这种方式做出来的东西体验较好，类似传统桌面程序，对于那些需要频繁操作的行业用户，有很大优势。二是运行的效率较高，之前集成一些菜单功能，可能要用iframe的方式引入，但每个iframe要独立引入一些公共文件，服务器文件传输的压力较大，还要初始化自己的一套内存环境，比较浪费，互相之间也不太方便通信，一般要通过postMessage之类的方式去交互。&lt;/p&gt;

&lt;p&gt;有了SPA之后，比如一块界面，就可以是一个HTML片段，用AJAX去加载过来处理之后放到界面上。如果有逻辑的JavaScript代码，也可以用require之类的异步加载机制去运行时加载，整体的思路是比较好的。&lt;/p&gt;

&lt;p&gt;很多人说，就以这样的需求，用jQuery再加一个异步js加载框架，不是很足够了吗？这两个东西用得好的话，也是能够解决一些问题的，但它们处理的并不是最关键的事情。在Web体系中，展现层是很天然的，因为就是HTML和CSS，如果只从文件隔离的角度，也可以做出一种划分的方式，逻辑放在单独的js文件里，html内部尽量不写js，这就是之前比较主流的前端代码划分方式。&lt;/p&gt;

&lt;p&gt;刚才我们提到，SPA开发的过程中会遇到一些困难，这些困难是因为复杂度大为提升，导致了一些问题，有人把这些困难归结为纯界面的复杂度，比如说，控件更复杂了之类，没有这么简单。问题在于什么呢？我打个比方：我们在电脑上开两个资源管理器窗口，浏览到同一个目录，在一个目录里把某个文件删了，你猜猜另外一个里面会不会刷新？&lt;/p&gt;

&lt;p&gt;毫无疑问，也会刷新，但是你看看你用的Web页面，如果把整个复杂系统整合成单页的，能保证对一个数据的更新就实时反馈到所有用它的地方吗？怎么做，是不是很头疼？代码组织的复杂度大为提高，所以需要做一些架构方面的提升。
#4. 架构的变更&lt;/p&gt;

&lt;p&gt;提到架构，我们通常会往设计模式上想。在著名的《设计模式》一书中，刚开始就讲了一种典型的处理客户端开发的场景，那就是MVC。&lt;/p&gt;

&lt;p&gt;传统的MVC理念我们并不陌生，因为有Struts，所以在Web领域也有比较经典的MVC架构，这里面的V，就负责了整个前端的渲染，而且是服务端的渲染，也就是输出HTML。如下图所示：&lt;/p&gt;

&lt;p&gt;struts-mvc.png&lt;/p&gt;

&lt;p&gt;在SPA时代，这已经不合适了，所以浏览器端形成了自己的MVC等层次，这里的V已经变成客户端渲染了，通常会使用一些客户端的HTML模版去实现，而模型和控制器，也相应地在浏览器端形成了。&lt;/p&gt;

&lt;p&gt;struts-mvc.png&lt;/p&gt;

&lt;p&gt;我们有很多这个层面的框架，比如Backbone，Knockout，Avalon，Angular等，采用了不同的设计思想，有的是MVC，有的是MVP，有的是MVVM，各有其特点。&lt;/p&gt;

&lt;p&gt;以Angular为例，它推荐使用双向绑定去实现视图和模型的关联，这么一来，如果不同视图绑定在同一模型上，就解决了刚才所说的问题。而模型本身也通过某种机制，跟其他的逻辑模块进行协作。&lt;/p&gt;

&lt;p&gt;这种方式就是依赖注入。依赖注入的核心理念就是通过配置来实例化所依赖的组件。使用这种模式来设计软件架构，会牺牲一些性能，在跟踪调试的便利性等方面也会有所损失，但换来的是无与伦比的松耦合和可替代性。&lt;/p&gt;

&lt;p&gt;比如说，这些组件就可以单独测试，然后在用的时候随手引入，毫无压力。对于从事某一领域的企业来说，光这一条就足以吸引他在上面大量投入，把所有不常变动领域模型的业务代码都用此类办法维护起来，这是一种财富。
#5. MV*框架的基本原理&lt;/p&gt;

&lt;p&gt;如果我们来设计Angular这么一个前端框架，应当如何入手呢？很显然，逻辑的控制必须使用JavaScript，一个框架，最本质的事情在于它的逻辑处理方式。&lt;/p&gt;

&lt;p&gt;我们的界面为什么可以多姿多彩？因为有HTML和CSS，注意到这两种东西都是配置式的写法，参照后端的依赖注入，如果把这两者视为跟Spring框架中一些XML等同的配置文件，思路就豁然开朗了。&lt;/p&gt;

&lt;p&gt;与后端不同的是，充当前端逻辑工具的JavaScript不能做入口，必须挂在HTML里才能运行，所以出现了一个怪异的状况：逻辑要先挂在配置文件（HTML）上，先由另外的容器（浏览器或者Hybird的壳）把配置文件加载起来，然后才能从某个入口开始执行逻辑。好消息是，过了这一步，逻辑层就开始大放异彩了。&lt;/p&gt;

&lt;p&gt;从这个时候开始，框架就启动了，它要做哪些事情呢？&lt;/p&gt;

&lt;p&gt;初始化自身（bootstrap）
异步加载可能尚未引入的JavaScript代码（require）
解析定义在HTML上的规则（template parser）
实例化模型（scope）
创建模型和DOM的关联关系（binding, injection）
这些是主线流程，还有一些支线，比如：&lt;/p&gt;

&lt;p&gt;解析url的search字符串，恢复状态（route）
加载HTML部件模板（template url）
部件模板和模型的关联（binding）
#6. 如何做组件化
6.1. HTML的组件化&lt;/p&gt;

&lt;p&gt;SPA的一个典型特征就是部分加载，界面的部件化也是其中比较重要的一环。界面片段在动态请求得到之后，借助模版引擎之类的技术，经过某种转换，放置到主界面相应的地方。所以，从这个角度来看，HTML的组件化非常容易理解，那就是界面的片段化和模板化。&lt;/p&gt;

&lt;p&gt;6.2. JavaScript的组件化&lt;/p&gt;

&lt;p&gt;JavaScript这个部分有好几个发展阶段。&lt;/p&gt;

&lt;p&gt;早期的共享文件，把公共功能的代码提出出来，多个页面共用
动态引用，消灭全局变量
在某些框架上进一步划分，比如Angular里面又分为provider，service，factory，controller
JavaScript组件化的目标是什么呢，是清晰的职责，松耦合，便于单元测试和重复利用。这里的松耦合不仅体现在js代码之间，也体现在js跟DOM之间的关系，所以像Angular这样的框架会有directive的概念，把DOM操作限制到这类代码中，其他任何js代码不操作DOM。&lt;/p&gt;

&lt;p&gt;componentsinspa.png&lt;/p&gt;

&lt;p&gt;如上图所示，总的原则是先分层次，层内再作切分。这么做的话，不再存在之前那种端到端组件了，使用起来没有原先那么方便，但在另外很多方面比较好。&lt;/p&gt;

&lt;p&gt;6.3. CSS的组件化&lt;/p&gt;

&lt;p&gt;这方面，业界也有很多探索，比如LESS，SASS，Stylus等。为什么CSS也要做组件化呢？传统的CSS是一种扁平的文本结构，变更成本较高，比如说想要把结构从松散改紧凑，需要改动很多。如果把实际使用的CSS只当作输出结果，而另外有一种适合变更的方式当作中间过程，这就好多了。比如说，我们把一些东西定义成变量，每个细节元素使用这些变量，当需要整体变更的时候，只需修改这些变量然后重新生成一下就可以了。&lt;/p&gt;

&lt;p&gt;以上，我们讨论了大致的Web前端开发的组件化思路，后续将阐述组件化之后的协作过程和管控机制。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Web应用组件化的权衡</title>
      <link>https://satisfied1.github.io/post/Web%E5%BA%94%E7%94%A8%E7%BB%84%E4%BB%B6%E5%8C%96%E7%9A%84%E6%9D%83%E8%A1%A1/</link>
      <pubDate>Thu, 08 Dec 2016 11:14:37 +0800</pubDate>
      
      <guid>https://satisfied1.github.io/post/Web%E5%BA%94%E7%94%A8%E7%BB%84%E4%BB%B6%E5%8C%96%E7%9A%84%E6%9D%83%E8%A1%A1/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;基本概念&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;什么是Web应用？&lt;/p&gt;

&lt;p&gt;所谓Web应用，指的是那些虽然用Web技术构建，但是展现形式却跟桌面程序或者移动端原生应用类似的产品。这类产品的特点是逻辑较重，交互复杂，通常也是单页式的。&lt;/p&gt;

&lt;p&gt;主要包括：&lt;/p&gt;

&lt;p&gt;交互占比较高的页面体系
以各种Hybrid技术构建的应用，其中的Web部分
大部分可以等同于所谓的“单页面应用”，可以参见之前写的这篇：构建单页Web应用&lt;/p&gt;

&lt;p&gt;组件化开发的优势是什么？&lt;/p&gt;

&lt;p&gt;组件化的最重要作用就是提升开发和维护的效率。&lt;/p&gt;

&lt;p&gt;最原始的组件，其功能可以单独开发测试，然后逐级拼装成更复杂的组件，直到整个应用。每一级都是易装配，可追踪，可管控的。&lt;/p&gt;

&lt;p&gt;在Web应用中，组件化一般指什么？&lt;/p&gt;

&lt;p&gt;在开发Web应用的时候，无论技术选型，工程方案，还是对人员的技能需求都是有一些特点的，最重要的特点莫过于组件化。&lt;/p&gt;

&lt;p&gt;组件化这个词，在UI这一层通常指“标签化”，也就是把大块的业务界面，拆分成若干小块，然后进行组装。&lt;/p&gt;

&lt;p&gt;狭义的组件化一般是指标签化，也就是以自定义标签（自定义属性）为核心的机制。&lt;/p&gt;

&lt;p&gt;广义的组件化包括对数据逻辑层业务梳理，形成不同层级的能力封装。&lt;/p&gt;

&lt;p&gt;在Web应用中，组件化的主要目标是什么？&lt;/p&gt;

&lt;p&gt;很多人会把复用作为组件化的第一需求，但实际上，在UI层，复用的价值远远比不上分治。&lt;/p&gt;

&lt;p&gt;分治带来的是可管理性，相比一大团HTML和JavaScript的混杂，组件化之后，整个应用成为了一个很清晰的树，一眼就能看清包含关系，也能够很容易理清数据的传递方向。而且，整个应用可以从叶子节点，逐步向上测试，哪一级出了问题，可以很容易发现。&lt;/p&gt;

&lt;p&gt;但是复用就很麻烦了，因为组件的内部实现与外部接口都很难取舍。很可能我们在设计之初，都是把组件设想成一个单一的东西，然后在实际项目中，发现最后都面目全非了。&lt;/p&gt;

&lt;p&gt;所以，复用的工程成本很高，在使用的时候需要权衡，除了最常用了基础控件，其他的不要刻意追求。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;组件化应当做到什么程度？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一个软件产品中，如果把核心稳定的部分视为资产，灵活可变的部分视为耗材，我们如何对待资产？如何对待耗材？&lt;/p&gt;

&lt;p&gt;对待资产，我们一般会比较重视，会有长远的规划，优雅的实现，持续的维护，细致的测试，详尽的文档等等，但是对于耗材，基本上会视为一次性的东西，不会有这么严谨的过程。&lt;/p&gt;

&lt;p&gt;组件属于资产还是耗材？模板呢？&lt;/p&gt;

&lt;p&gt;按照上面的分类，组件明显属于资产，而模板一般属于耗材。&lt;/p&gt;

&lt;p&gt;在有些框架中，模板的使用度较低，但是常见的包含双向绑定的框架中，都有很大比重的模板。有些模板是嵌入到组件内部的，有些则是独立存在的，比如Angular中，可以使用ng-include动态包含一个模板，这个模板就是独立的了。&lt;/p&gt;

&lt;p&gt;大部分Web应用中，资产多一些，还是耗材多一些？&lt;/p&gt;

&lt;p&gt;大部分Web系统的前端部分，其实都是耗材比资产多，人们选用Web相关技术的一个典型心理就是容易写，而且相对随意一些。&lt;/p&gt;

&lt;p&gt;大部分Web应用都适合“全”组件化吗？&lt;/p&gt;

&lt;p&gt;这个问题要从几个方面回答：&lt;/p&gt;

&lt;p&gt;成本。从技术角度，任何系统都是可以不计成本的，如果资源无限充足，我们可以把每个东西都实现得非常完美，但现实世界不是这样的，每个东西都会有开发时间之类的限制，这就迫使我们只能对重要性较高，可复用性较高的东西多花时间，其他东西少花时间。
实现难度。组件化方案是需要有规划能力的，不但需要全局的规划能力，还需要各个局部的规划能力，这其实是比较高的需求了。
集成难度。很多时候，我们做一个东西，并不是就只有它自己，还会有跟其他系统的集成，比如说“我的淘宝”PC版，它现在的版本是用React实现的，但仍然需要跟其他东西集成，比如公共头尾，购物车之类，而这些东西是需要兼顾老系统，所以可能就会集成得比较别扭。一切组件化框架，如果要跟其他异构系统作集成，基本上都不可能优雅。
组件与模板的对比&lt;/p&gt;

&lt;p&gt;在展示内容偏多的网站中，模板是一个很常见的东西，它通过某种占位的HTML，包含简单的文本格式化，简单的条件判断，做一些很基础的动态内容生成操作。&lt;/p&gt;

&lt;p&gt;但是在Web应用中，因为强调组件化，所以很多人对模板的重要性有些忽视了。这里的“模板”指的是双向绑定的动态模板，不是传统的静态模板，这个基本概念之前有过回答：&lt;/p&gt;

&lt;p&gt;Handlebars 和angularjs有什么区别？分别在什么情况下使用？&lt;/p&gt;

&lt;p&gt;在Web应用中，应当如何看待模板的地位呢？我们先来看另外一个问题：&lt;/p&gt;

&lt;p&gt;HTML，CSS，JS，这三者里面，谁是整个Web工程的入口？&lt;/p&gt;

&lt;p&gt;展示型的Web项目中，毫无疑问HTML是入口，也是根基，不管是JS还是CSS都是作为它的辅助。但到了Web应用中，还是这样吗？我们很多Web应用实际上是以JS为入口的，HTML不再被视为骨架，而是视为一种动态的东西，由JS创建并管理。&lt;/p&gt;

&lt;p&gt;在这个前提下，人们对动态的HTML又有两种不同方式的认知：它是模板，还是组件？&lt;/p&gt;

&lt;p&gt;从典型的MVVM三层中，我们可以看到，View Model是Model的外围，View是View Model的外围，一层一层出去，外层实际上可以视为内层的配置文件。而如果从组件化的角度出发，View跟View Model共同构成了组件层。&lt;/p&gt;

&lt;p&gt;因此，动态的HTML究竟算是什么，取决于我们从什么角度去看待它，也取决于我们在使用什么框架。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;组件化框架&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;目前有哪些流行的组件化框架？&lt;/p&gt;

&lt;p&gt;我们现在开发Web应用，一般也不会从0开始，通常是选取一个核心框架（库），然后在此基础上确定一些规则，逐步构建外围体系，现在比较火的有React，Angular，Vue，Polymer等。&lt;/p&gt;

&lt;p&gt;“MV*”：Angular，Vue等
“反应式”：React，Reactive等
标准增强：Polymer&lt;/p&gt;

&lt;p&gt;几个流派各自特点是什么？&lt;/p&gt;

&lt;p&gt;MV*: 分层，绑定
React: 组件化，单向数据流&lt;/p&gt;

&lt;p&gt;React中一般的组件相当于MVVM流派中的什么？&lt;/p&gt;

&lt;p&gt;以上提到的几个东西，在组件化这块，可能争议最大的是Angular，因为Angular 1.x的官方指引中，并未在组件化这个方向上作一些指导，也没有提倡，甚至连建议都没有，而React和Polymer是天然组件化的，Vue提供的文档里以很大篇幅详细说明了组件化的机制和实践方式。&lt;/p&gt;

&lt;p&gt;但是，这并不是说，Angular 1.x就是与组件化冲突的，它仍然可以通过directive等相关机制，实现自己特色的组件化方案。&lt;/p&gt;

&lt;p&gt;Directive可以实现自定义标签和自定义属性，这两者可以理所当然地归类到组件中，但是，在Angular中，模板本身也可以视为一种组件，一种轻量级的组件，它不一定就是静态的，仍然可以有一些简单的操作和行为。&lt;/p&gt;

&lt;p&gt;Directive和模板相当于MVVM中的View层，它们的运行，一般是离不开ViewModel的支撑的，在Angular中，这就是controller。所以，如果以Angular框架来说，directive和模板、controller，共同形成了视图层组件体系。推广到其他MVVM框架来说，也就是View和ViewModel，而React整体就处于视图层，所以这两者算是一个对等关系。&lt;/p&gt;

&lt;p&gt;这些流派有共同的未来吗，会是什么？&lt;/p&gt;

&lt;p&gt;无论是哪种框架，在开发Web应用的时候都要面临一个问题：业务数据层如何设计？&lt;/p&gt;

&lt;p&gt;这一层东西，其实目前各路框架都未提出有力的解决方案，大家的重点都还是在做上层UI。&lt;/p&gt;

&lt;p&gt;但是从长远来看，业务数据层会是一个基本没有框架差异的东西，同一个方案，大家都可以用，比如说之前有人把flux之类的东西放到React之外的框架用，也一样可以。&lt;/p&gt;

&lt;p&gt;而上层UI，其实现过程现在也很明确地是要往Web Components靠拢，实现逻辑都是使用ES新标准，数据绑定机制都是getter setter或者observe，加载方式都在考虑HTTP2之类，一旦某个领域出现了理念突破，很快就会被其他框架吸收融合。&lt;/p&gt;

&lt;p&gt;所以总的来说，各框架是趋同的。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;组件化的实践&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一个全组件化体系，会形成组件树，上下级组件之间应当如何通讯？不同层级的组件之间应当如何通讯？&lt;/p&gt;

&lt;p&gt;当我们把一个应用使用组件化的理念进行构建的时候，整个应用就形成了一个倒置的树，树根就是应用本身，其余节点是层层嵌套的组件们，叶子节点是最基础的组件。&lt;/p&gt;

&lt;p&gt;如何规划组件树的层级与组件的粒度？&lt;/p&gt;

&lt;p&gt;如果我们有两个不同团队，同样基于组件化的理念，使用同一个框架，做同样功能的产品，最终形成的组件树可能差别很大，这个差别主要在于：&lt;/p&gt;

&lt;p&gt;把什么视为组件，组件的粒度是怎样的。&lt;/p&gt;

&lt;p&gt;在组件化的应用中，组件树的层级不宜过深，从根节点算起，应当尽可能控制在3到5层内，如果层级太多的话，会造成组件通讯和数据传递的负担。&lt;/p&gt;

&lt;p&gt;如何约定组件之间的通讯方式？&lt;/p&gt;

&lt;p&gt;在一个组件化的应用中，会存在组件之间的数据传递。&lt;/p&gt;

&lt;p&gt;以React为例，如果存在两级嵌套的组件：&lt;/p&gt;

&lt;p&gt;&lt;TodoList&gt;
    &lt;TodoItem&gt;&lt;/TodoItem&gt;
    &lt;TodoItem&gt;&lt;/TodoItem&gt;
    &lt;TodoItem&gt;&lt;/TodoItem&gt;
&lt;/TodoList&gt;
这里面可能存在：&lt;/p&gt;

&lt;p&gt;直接对TodoList进行整组数据的赋值
直接对某个TodoItem赋值
TodoList对下属的TodoItem赋值
TodoList和TodoItem自己去某个“全局”数据中读取配置项
这里面，前三种都可以通过该组件的props传递进去，属于对组件的常规用法，第四种，则属于对数据层的利用。&lt;/p&gt;

&lt;p&gt;那么，我们如何权衡两种数据通讯方式呢？&lt;/p&gt;

&lt;p&gt;一个比较粗糙的办法是，从数据模型的角度去考虑。如果一个组件所要获取的数据模型是比较独立的，不依赖其他业务数据，可以直接去获取，如果跟其他这个数据模型跟其他数据之间存在耦合，比如主从联动关系，由父组件进行分发会比较好。&lt;/p&gt;

&lt;p&gt;另外一个着眼点是权衡上下两级组件之间的关系密切程度，如果它们之间的关系很强，对外界来说是一个紧密结合的整体，可以直接在它们之间传递数据，如果关系不强，或者在组件树上距离较远，适合通过第三方转发通信。&lt;/p&gt;

&lt;p&gt;从这里我们得出的结论是：&lt;/p&gt;

&lt;p&gt;并不是选择了框架，就可以顺利把一个Web应用做出来了，还需要一件很重要的事，那就是：业务架构。组件之间的关系都是需要统筹规划的，这里面有很多技巧，可以参见一些大型桌面程序的架构，从中获取不少经验。&lt;/p&gt;

&lt;p&gt;数据通讯层&lt;/p&gt;

&lt;p&gt;全组件化还带来另外一个课题，那就是数据层的设计。比如说，我们可能有一个选择城市的列表组件，它的数据来源于服务端的一个查询，为了方便起见，很可能你会选择把查询的调用封装在组件内部，然后这个组件如果被同一个可见区域的多个部分使用，或者是这个查询及其数据结果被同一可见区域的其他组件也调用了，就出现了两个问题：&lt;/p&gt;

&lt;p&gt;数据同步
请求的浪费
另外，对于关联数据的更新，也不太便于控制，RESTful之类的服务端接口规范在复杂场景下会显得力不从心。&lt;/p&gt;

&lt;p&gt;在数据通信这层，Meteor这样的框架提出了自己的解决思路，跳出传统HTTP的局限，把眼光转向WebSocket这样的东西，并且在前端实现类似数据库的访问接口。&lt;/p&gt;

&lt;p&gt;Facebook对此问题提出了更暴力的解决方式，Relay和GraphQL，这两个东西我认为意义是很大的，它解决的不光是自己的痛点，而且是可以用于其他任意的前端组件化体系，对前端组件化这个领域的完善度作出了极其重大的贡献。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;其他思考&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如何看待“可视化继承”？&lt;/p&gt;

&lt;p&gt;在不少组件化框架，包括桌面端的，Web端的，都有“可视化继承”这个概念，比如说，我们有一个List组件用于展现列表数据，然后，又有另外一个需求，在这个列表上显示checkbox，用于多选。在很多组件化框架里，都会存在这样的继承关系：&lt;/p&gt;

&lt;p&gt;class CheckList extends List {
}
我觉得有必要探讨一下这里这个extends，是不是一定要用这样的方式来实现一个形态类似原组件的新组件？&lt;/p&gt;

&lt;p&gt;在全组件式体系中，继承是不如组合优雅的，以上面这个情况来说，它会在render方法里，重新实现自己的东西，所以，它继承了什么呢，很少很少的东西。&lt;/p&gt;

&lt;p&gt;我们可以换种思路，保持组件不变，通过不同的配置项使其相应不同的功能。&lt;/p&gt;

&lt;p&gt;模板外置的组件实现方式&lt;/p&gt;

&lt;p&gt;在实现一个很基础的UI组件的时候，我们一般都会想要把它搞得既简洁，又强大，但这件事情本身是很难权衡的，针对不同的组件，可能会有不同的策略。&lt;/p&gt;

&lt;p&gt;我们在开始实现组件的时候，通常会尽可能考虑需求，然后将其作为默认实现，并且对外提供一些配置项，用于开关这些功能。&lt;/p&gt;

&lt;p&gt;还是用列表举例，比如我们有一个列表，可以用于选中，内部结构可能会搞成这样：&lt;/p&gt;

&lt;p&gt;&lt;ul class=&#34;list&#34;&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li class=&#34;selected&#34;&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
然后对外的形式这样：&lt;/p&gt;

&lt;p&gt;&lt;List data=&#34;arr&#34;&gt;&lt;/List&gt;
或者这样：&lt;/p&gt;

&lt;p&gt;&lt;List&gt;
    &lt;ListItem data=&#34;aaa&#34;&gt;&lt;/ListItem&gt;
    &lt;ListItem data=&#34;bbb&#34; selected&gt;&lt;/ListItem&gt;
    &lt;ListItem data=&#34;ccc&#34;&gt;&lt;/ListItem&gt;
    &lt;ListItem data=&#34;ddd&#34;&gt;&lt;/ListItem&gt;
&lt;/List&gt;
然后，加需求了，列表有多种形态，一种横着排的，一种竖着排的，一种片状的，每行N个，排满换行，然后这里面还再分，元素是否定宽，还是流式。&lt;/p&gt;

&lt;p&gt;那我们就面临着几个选择：&lt;/p&gt;

&lt;p&gt;&lt;List type=&#34;Tile&#34;&gt;&lt;/List&gt;
加配置属性，或者增加不同的元素，如TileList，HorizontalList等等。&lt;/p&gt;

&lt;p&gt;接着，我们来了对列表项的自定义需求：&lt;/p&gt;

&lt;p&gt;每个列表项带一个checkbox。
列表可以设置有无表头。
表头可以设置有无checkbox。
如果表头有checkbox，需要跟每行的checkbox状态进行关联。当表头checkbox点击的时候，所有行的checkbox与它同步；当每行checkbox点击的时候，表头checkbox状态也与之同步。
checkbox需要可以设置显示在列表左侧还是右侧
列表内容可以自定义文本格式化函数
列表内容可以自定义为其他组件，并且有一些数据传递和事件通信方式……
然后，还要可以自定义样式……
……
所以，这个组件变得非常复杂，对外的接口很复杂，内部实现也很复杂，代码更是臃肿不堪。摆在我们面前的有这么一个矛盾：&lt;/p&gt;

&lt;p&gt;怎样让我们的组件既强大，又便于使用？&lt;/p&gt;

&lt;p&gt;面对此类场景，我想给出一个解决方案，那就是：&lt;/p&gt;

&lt;p&gt;把组件实现为一种插件平台
针对组件的各种形态，将其特征分离出来当成一种插件
为了说明这个理念，我花了大约一个小时，写了这样一个demo，看其中datagrid那段。&lt;/p&gt;

&lt;p&gt;其主体实现逻辑是这段：datagrid.js&lt;/p&gt;

&lt;p&gt;看看这个代码，再对比所展示出来的这些功能，会不会觉得差异有点大？&lt;/p&gt;

&lt;p&gt;奥秘在哪里呢，在于我们给每种场景传入了不同的模板，如下：&lt;/p&gt;

&lt;p&gt;&lt;sn-datagrid grid-cols=&#34;cols&#34; grid-data=&#34;students&#34;&gt;&lt;/sn-datagrid&gt;&lt;/p&gt;

&lt;p&gt;&lt;sn-datagrid grid-cols=&#34;cols&#34; grid-data=&#34;students&#34; header-cell-tpl=&#34;sortHeaderTpl&#34;&gt;&lt;/sn-datagrid&gt;&lt;/p&gt;

&lt;p&gt;&lt;sn-datagrid grid-cols=&#34;checkboxCols&#34; grid-data=&#34;students&#34; cell-tpl=&#34;checkboxTpl&#34; header-cell-tpl=&#34;checkboxHeaderTpl&#34;&gt;&lt;/sn-datagrid&gt;&lt;/p&gt;

&lt;p&gt;&lt;sn-datagrid grid-cols=&#34;buttonCols&#34; grid-data=&#34;students&#34; cell-tpl=&#34;buttonCellTpl&#34; header-cell-tpl=&#34;checkboxHeaderTpl&#34;&gt;&lt;/sn-datagrid&gt;
这个理念其实并不新鲜，在Adobe Flex的组件框架中，List系列的组件就通过开放自定义itemRenderer的方式，极大提升了可扩展性，并且保持原组件实现的优雅。同理，使用类似的方式，用React也可以这样实现。&lt;/p&gt;

&lt;p&gt;但我们这个地方会更加简洁，其原因在于两点：&lt;/p&gt;

&lt;p&gt;Angular的模板即可起到轻量组件的作用，代码更精炼
Angular的作用域有继承机制，这样，传入的模板直接与原组件融为一体，共享同一份数据
对于Angular的这个作用域机制，很多人都反感，但我认为，它并不一定就比全部在传递时候赋值的immutable机制差，在业务开发中，组件化固然是有用，但频繁的上下级数据传递可能会让整个系统更加零碎化，数据层的零碎化是非常不利的。&lt;/p&gt;

&lt;p&gt;今年大家有了React，黑Angular就格外狠了，我举这个例子也是为了说明，Angular 1.x的设计，除了module是完全的败笔，变更检测机制值得商榷，其他的并无大问题，甚至还存在一些优势。使用某框架的时候，如果熟悉原理并加以合理利用，能够巧妙解决业务上遇到的很多问题。&lt;/p&gt;

&lt;p&gt;模板的意义&lt;/p&gt;

&lt;p&gt;除了上面提到的，模板还有另外的意义。&lt;/p&gt;

&lt;p&gt;我们会发现，在React的体系里，HTML和DOM本身还重要吗？重要性其实是大幅降低了，所以我们会看到ReactNative，ReactCanvas之类的实现，而且，最新版本的React中，把React DOM单独抽取出来了，这意味着，React未来只把DOM作为它的可选视图渲染层之一。&lt;/p&gt;

&lt;p&gt;但是我们必须认识到，在Web体系中，HTML和DOM有不可替代的优势，它们是当前Web技术的根基，尽管有缺点，并不代表应当被抛弃，至少是在现在这个时代。&lt;/p&gt;

&lt;p&gt;所以，在Web应用这样的体系中，组件的实现技术还是应当尽可能基于DOM来考虑。也正是在这种场景下，模板和绑定技术仍然存在很重要的作用，比如可访问性等等特性，都是别的非DOM体系所缺乏积累的。&lt;/p&gt;

&lt;p&gt;此外，模板某种程度上可以视为“组件的字面量形式”，也就是组件的一种序列化形式，如果我们要动态加载组件，使用模板会非常方便，这也就是我上面那个数据表格例子的意义所在。&lt;/p&gt;

&lt;p&gt;HTML体系做组件化的不利因素&lt;/p&gt;

&lt;p&gt;HTML本身的标签，其实做组件化是有些别扭的，这个原因在哪里呢，两点：&lt;/p&gt;

&lt;p&gt;标签没有命名空间
有些内置标签是依赖于别的标签而存在的，并且往往有默认的布局语义，比如TR，比如LI，这些东西单独跟内部一些元素一起封装而成的“组件”，并不能做到可以任意放置。
在其他一些体系里并不存在这样的问题，比如WPF，比如Adobe Flex，因为他们没有这样的“历史负担”。&lt;/p&gt;

&lt;p&gt;另外一个方面，所谓的组件嵌套，从声明式代码的编写方式来看，就是标签的嵌套。标签嵌套的含义在UI层被赋予了更多潜规则，比如这个代码：&lt;/p&gt;

&lt;p&gt;&lt;Panel&gt;
  &lt;Service/&gt;
&lt;/Panel&gt;
如果Service并非有UI展现的东西，而是像polymer里面的core-ajax那样，或者Adobe Flash体系里的WebService，你可以把它当做Panel实例里面的一个成员变量，然后设置它的属性或者调用方法。但是，对于更普通的情形：&lt;/p&gt;

&lt;p&gt;&lt;Panel&gt;
  &lt;Button&gt;&lt;/Button&gt;
&lt;/Panel&gt;
同样的写法，这个含义一样吗？很明显不一样，因为Button也是一个可展示的组件，这时候你默认它是被放置在Panel的展现内部，作为它的可视化子元素的。也就是说，这时候，你不但在逻辑上把两者建立了关联，还要在布局上考虑它们的约束。&lt;/p&gt;

&lt;p&gt;如果你的外层元素是一个布局为主的容器，那好说，比如这里的Panel，我们默认它有一块展示区，所有子节点都放在里面以某种方式排版，或者flow，或者float，或者flex，甚至border-layout，东西南北中。&lt;/p&gt;

&lt;p&gt;如果外层元素不是一个布局为主的容器，允许它嵌套别的东西，逻辑上就很难理解。它必须约束自己所能允许放置的子元素的类型。比如：&lt;/p&gt;

&lt;p&gt;List下面就只能放ListItem类型的东西。&lt;/p&gt;

&lt;p&gt;再回头看Web Components&lt;/p&gt;

&lt;p&gt;我觉得，在有了类似angular那种自定义元素、属性的方式（具体实现可以改进），或者React那种自定义标签之后，Web Components的使用场景变得很尴尬了。&lt;/p&gt;

&lt;p&gt;我们现在看Web Components的作用，主要还是隔离，包括对逻辑和内部展现的隔离。JavaScript逻辑的隔离其实作用不是很大，因为我们用其他办法也能达到相同的效果，但是Shadow DOM和Scoped CSS这两个东西就很耐人寻味了。&lt;/p&gt;

&lt;p&gt;比如说，我们现在用Shadow DOM实现了一个东西，然后，在浏览器里面打开查看开关，还是可以看到里面的东西，那如果不纠结它的实现机制的话，跟使用某种组件化框架创建的自定义元素相比，差异是不是就没有那么大了？因为写的时候都只是写一个自定义的元素，运行的时候在内部放了具体实现细节。&lt;/p&gt;

&lt;p&gt;至于Scoped CSS，更有意思，因为它实际上带来了对已有的工程方案的挑战。我们思考Web Components普及之后的组件化思路，在样式这块几乎都必然走到一条路上，那就是：样式的inline化，把组件的样式全部内置，否则，组件的独立性无从保证。但我们不要忘了，/deep/和::shadow选择器是用来干什么的？这是允许外部的样式对组件内部的东西作调整，这是一个很无奈的选择，因为确实有这种场景，比如你需要对所有组件设置全局风格之类。另外上次听谁说到父选择器，允许元素控制其上级的样式……真是被震惊了，我理解这种需求，比如某种图片放到一个容器里，不管它放在哪，都希望其父容器背景如何如何，但是，这是对组件化技术的一种挑战……&lt;/p&gt;

&lt;p&gt;在实际工程中，样式inline化是有很多缺陷的，比如刚才提到的：theme怎么办？从我近期的一些文章可以看到观点，就是不赞同全组件化，尤其是在上层更倾向于直接使用HTML模板而不是封装过的组件，因为我认为：Web，或者说泛HTML体系，它跟其他任何的客户端展现技术，比如Java Swing，WPF，QT，Adobe Flex之类相比，最本质的不同在于极其强大的CSS，正是因为有它，我们才有可能极尽所能地、简单而优雅地打造不同的用户体验，而不是用各种画布去绘制像素。如果你决定在底层去各种绘制，那确实可以把UI层全组件化，但这个事情也只能在有限范围干，比如移动端，比如游戏，否则代价不堪设想。&lt;/p&gt;

&lt;p&gt;面对theme的需求，我们只能通过往动态构建的路上去走，这里面也会有很多要考虑的点。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;小结&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看到这里，有什么感觉？想要在有一定复杂度的Web应用中全面推行组件化，需要考虑的东西非常多，相当于从农业社会到工业社会的飞跃，我们不能期望一蹴而就，需要通盘考虑。&lt;/p&gt;

&lt;p&gt;各类客户端开发技术中有很多值得借鉴的地方，结合Web技术自身的一些特点，可以触类旁通。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>构建单页面程序</title>
      <link>https://satisfied1.github.io/post/%E6%9E%84%E5%BB%BA%E5%8D%95%E9%A1%B5%E9%9D%A2%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Thu, 08 Dec 2016 11:14:12 +0800</pubDate>
      
      <guid>https://satisfied1.github.io/post/%E6%9E%84%E5%BB%BA%E5%8D%95%E9%A1%B5%E9%9D%A2%E7%A8%8B%E5%BA%8F/</guid>
      <description>&lt;p&gt;构建单页Web应用&lt;/p&gt;

&lt;p&gt;单页应用是什么？&lt;/p&gt;

&lt;p&gt;让我们先来看几个网站：&lt;/p&gt;

&lt;p&gt;coding&lt;/p&gt;

&lt;p&gt;teambition&lt;/p&gt;

&lt;p&gt;cloud9&lt;/p&gt;

&lt;p&gt;注意这几个网站的相同点，那就是在浏览器中，做了原先“应当”在客户端做的事情。它们的界面切换非常流畅，响应很迅速，跟传统的网页明显不一样，它们是什么呢？这就是单页Web应用。&lt;/p&gt;

&lt;p&gt;所谓单页应用，指的是在一个页面上集成多种功能，甚至整个系统就只有一个页面，所有的业务功能都是它的子模块，通过特定的方式挂接到主界面上。它是AJAX技术的进一步升华，把AJAX的无刷新机制发挥到极致，因此能造就与桌面程序媲美的流畅用户体验。&lt;/p&gt;

&lt;p&gt;其实单页应用我们并不陌生，很多人写过ExtJS的项目，用它实现的系统，很天然的就已经是单页的了，也有人用jQuery或者其他框架实现过类似的东西。用各种JS框架，甚至不用框架，都是可以实现单页应用的，它只是一种理念。有些框架适用于开发这种系统，如果使用它们，可以得到很多便利。&lt;/p&gt;

&lt;p&gt;开发框架&lt;/p&gt;

&lt;p&gt;ExtJS可以称为第一代单页应用框架的典型，它封装了各种UI组件，用户主要使用JavaScript来完成整个前端部分，甚至包括布局。随着功能逐渐增加，ExtJS的体积也逐渐增大，即使用于内部系统的开发，有时候也显得笨重了，更不用说开发以上这类运行在互联网上的系统。&lt;/p&gt;

&lt;p&gt;jQuery由于偏重DOM操作，它的插件体系又比较松散，所以比ExtJS这个体系更适合开发在公网运行的单页系统，整个解决方案会相对比较轻量、灵活。&lt;/p&gt;

&lt;p&gt;但由于jQuery主要面向上层操作，它对代码的组织是缺乏约束的。如何在代码急剧膨胀的情况下控制每个模块的内聚性，并且适当在模块之间产生数据传递与共享，就成为了一种有挑战的事情。&lt;/p&gt;

&lt;p&gt;为了解决单页应用规模增大时候的代码逻辑问题，出现了不少MV*框架，他们的基本思路都是在JS层创建模块分层和通信机制。有的是MVC，有的是MVP，有的是MVVM，而且，它们几乎都在这些模式上产生了变异，以适应前端开发的特点。&lt;/p&gt;

&lt;p&gt;这类框架包括Backbone，Knockout，AngularJS，Avalon等。&lt;/p&gt;

&lt;p&gt;组件化&lt;/p&gt;

&lt;p&gt;这些在前端做分层的框架推动了代码的组件化，所谓组件化，在传统的Web产品中，更多的指UI组件，但其实组件是一个广泛概念，传统Web产品中UI组件占比高的原因是它的厚度不足，随着客户端代码比例的增加，相当一部分的业务逻辑也前端化，由此催生了很多非界面型组件的出现。&lt;/p&gt;

&lt;p&gt;分层带来的一个优势是，每层的职责更专一了，由此，可以对其作单元测试的覆盖，以保证其质量。传统UI层测试最头疼的问题是UI层和逻辑混杂在一起，比如往往会在远程请求的回调中更改DOM，当引入分层之后，这些东西都可以分别被测试，然后再通过场景测试来保证整体流程。&lt;/p&gt;

&lt;p&gt;代码隔离&lt;/p&gt;

&lt;p&gt;与开发传统页面型网站相比，实现单页应用的过程中，有一些比较值得特别关注的点。&lt;/p&gt;

&lt;p&gt;从单页应用的特点来看，它比页面型网站更加依赖于JavaScript，而由于页面的单页化，各种子功能的JavaScript代码聚集到了同一个作用域，所以代码的隔离、模块化变得很重要。&lt;/p&gt;

&lt;p&gt;在单页应用中，页面模板的使用是很普遍的。很多框架内置了特定的模板，也有的框架需要引入第三方的模板。这种模板是界面片段，我们可以把它们类比成JavaScript模块，它们是另一种类型的组件。&lt;/p&gt;

&lt;p&gt;模板也一样有隔离的需要。不隔离模板，会造成什么问题呢？模板间的冲突主要存在于id属性上，如果一个模板中包含固定的id，当它被批量渲染的时候，会造成同一个页面的作用域中出现多个相同id的元素，产生不可预测的后果。因此，我们需要在模板中避免使用id，如果有对DOM的访问需求，应当通过其他选择器来完成。如果一个单页应用的组件化程度非常高，很可能整个应用中都没有元素id的使用。&lt;/p&gt;

&lt;p&gt;代码合并与加载策略&lt;/p&gt;

&lt;p&gt;人们对于单页系统的加载时间容忍度与Web页面不同，如果说他们愿意为购物页面的加载等待3秒，有可能会愿意为单页应用的首次加载等待5-10秒，但在此之后，各种功能的使用应当都比较流畅，所有子功能页面尽量要在1-2秒时间内切换成功，否则他们就会感觉这个系统很慢。&lt;/p&gt;

&lt;p&gt;从这些特点来看，我们可以把更多的公共功能放到首次加载，以减小每次加载的载入量，有一些站点甚至把所有的界面和逻辑全部放到首页加载，每次业务界面切换的时候，只产生数据请求，因此它的响应是非常迅速的，比如青云的控制台就是这么做的。&lt;/p&gt;

&lt;p&gt;通常在单页应用中，无需像网站型产品一样，为了防止文件加载阻塞渲染，把js放到html后面加载，因为它的界面基本都是动态生成的。&lt;/p&gt;

&lt;p&gt;当切换功能的时候，除了产生数据请求，还需要渲染界面，这个新渲染的界面部件一般是界面模板，它从哪里来呢？来源无非是两种，一种是即时请求，像请求数据那样通过AJAX获取过来，另一种是内置于主界面的某些位置，比如script标签或者不可见的textarea中，后者在切换功能的时候速度有优势，但是加重了主页面的负担。&lt;/p&gt;

&lt;p&gt;在传统的页面型网站中，页面之间是互相隔离的，因此，如果在页面间存在可复用的代码，一般是提取成单独的文件，并且可能会需要按照每个页面的需求去进行合并。单页应用中，如果总的代码量不大，可以整体打包一次在首页载入，如果大到一定规模，再作运行时加载，加载的粒度可以搞得比较大，不同的块之间没有重复部分。&lt;/p&gt;

&lt;p&gt;路由与状态的管理&lt;/p&gt;

&lt;p&gt;我们最开始看到的几个在线应用，有的是对路由作了管理的，有的没有。&lt;/p&gt;

&lt;p&gt;管理路由的目的是什么呢？是为了能减少用户的导航成本。比如说我们有一个功能，经历过多次导航菜单的点击，才呈现出来。如果用户想要把这个功能地址分享给别人，他怎么才能做到呢？&lt;/p&gt;

&lt;p&gt;传统的页面型产品是不存在这个问题的，因为它就是以页面为单位的，也有的时候，服务端路由处理了这一切。但是在单页应用中，这成为了问题，因为我们只有一个页面，界面上的各种功能区块是动态生成的。所以我们要通过对路由的管理，来实现这样的功能。&lt;/p&gt;

&lt;p&gt;具体的做法就是把产品功能划分为若干状态，每个状态映射到相应的路由，然后通过pushState这样的机制，动态解析路由，使之与功能界面匹配。&lt;/p&gt;

&lt;p&gt;有了路由之后，我们的单页面产品就可以前进后退，就像是在不同页面之间一样。&lt;/p&gt;

&lt;p&gt;其实在Web产品之外，早就有了管理路由的技术方案，Adobe Flex中，就会把比如TabNavigator，甚至下拉框的选中状态对应到url上，因为它也是单“页面”的产品模式，需要面对同样的问题。&lt;/p&gt;

&lt;p&gt;当产品状态复杂到一定程度的时候，路由又变得很难应用了，因为状态的管理极其麻烦，比如开始的时候我们演示的c9.io在线IDE，它就没法把状态对应到url上。&lt;/p&gt;

&lt;p&gt;缓存与本地存储&lt;/p&gt;

&lt;p&gt;在单页应用的运作机制中，缓存是一个很重要的环节。&lt;/p&gt;

&lt;p&gt;由于这类系统的前端部分几乎全是静态文件，所以它能够有机会利用浏览器的缓存机制，而比如动态加载的界面模板，也完全可以做一些自定义的缓存机制，在非首次的请求中直接取缓存的版本，以加快加载速度。&lt;/p&gt;

&lt;p&gt;甚至，也出现了一些方案，在动态加载JavaScript代码的同时，把它们也缓存起来。比如Addy Osmani的这个basket.js，就利用了HTML5 localStorage作了js和css文件的缓存。&lt;/p&gt;

&lt;p&gt;在单页产品中，业务代码也常常会需要跟本地存储打交道，存储一些临时数据，可以使用localStorage或者localStorageDB来简化自己的业务代码。&lt;/p&gt;

&lt;p&gt;服务端通信&lt;/p&gt;

&lt;p&gt;传统的Web产品通常使用JSONP或者AJAX这样的方式与服务端通信，但在单页Web应用中，有很大一部分采用WebSocket这样的实时通讯方式。&lt;/p&gt;

&lt;p&gt;WebSocket与传统基于HTTP的通信机制相比，有很大的优势。它可以让服务端很便利地使用反向推送，前端只响应确实产生业务数据的事件，减少一遍又一遍无意义的AJAX轮询。&lt;/p&gt;

&lt;p&gt;由于WebSocket只在比较先进的浏览器上被支持，有一些库提供了在不同浏览器中的兼容方案，比如socket.io，它在不支持WebSocket的浏览器上会降级成使用AJAX或JSONP等方式，对业务代码完全透明、兼容。&lt;/p&gt;

&lt;p&gt;内存管理&lt;/p&gt;

&lt;p&gt;传统的Web页面一般是不需要考虑内存的管理的，因为用户的停留时间相对少，即使出现内存泄漏，可能很快就被刷新页面之类的操作冲掉了，但单页应用是不同的，它的用户很可能会把它开一整天，因此，我们需要对其中的DOM操作、网络连接等部分格外小心。&lt;/p&gt;

&lt;p&gt;样式的规划&lt;/p&gt;

&lt;p&gt;在单页应用中，因为页面的集成度高，所有页面聚集到同一作用域，样式的规划也变得重要了。&lt;/p&gt;

&lt;p&gt;样式规划主要是几个方面：&lt;/p&gt;

&lt;p&gt;基准样式的分离&lt;/p&gt;

&lt;p&gt;这里面主要包括浏览器样式的重设、全局字体的设置、布局的基本约定和响应式支持。&lt;/p&gt;

&lt;p&gt;组件样式的划分&lt;/p&gt;

&lt;p&gt;这里面是两个层面的规划，首先是各种界面组件及其子元素的样式，其次是一些修饰样式。组件样式应当尽量减少互相依赖，各组件的样式允许冗余。&lt;/p&gt;

&lt;p&gt;堆叠次序的管理&lt;/p&gt;

&lt;p&gt;传统Web页面的特点是元素多，但是层次少，单页应用会有些不同。&lt;/p&gt;

&lt;p&gt;在单页应用中，需要提前为各种UI组件规划堆叠次序，也就是z-index，比如说，我们可能会有各种弹出对话框，浮动层，它们可能组合成各种堆叠状态。新的对话框的z-index需要比旧的高，才能确保盖在它上面。诸如此类，都需要我们对这些可能的遮盖作规划，那么，怎样去规划呢？&lt;/p&gt;

&lt;p&gt;了解通信知识的人，应当会知道，不同的频率段被划分给不同的通信方式使用，在一些国家，领空的使用也是有划分的，我们也可以用同样的方式来预先分段，不同类型的组件的z-index落到各自的区间，以避免它们的冲突。&lt;/p&gt;

&lt;p&gt;单页应用的产品形态&lt;/p&gt;

&lt;p&gt;我们在开始的时候提到，存在着很多新型Web产品，使用单页应用的方式构建，但实际上，这类产品不仅仅存在于Web上。点开Chrome商店，我们会发现很多离线应用，这些产品都可以算是单页应用的体现。&lt;/p&gt;

&lt;p&gt;除了各种浏览器插件，借助node-webkit这样的外壳平台，我们可以使用Web技术来构建本地应用，产品的主要部分仍然是我们熟悉的单页应用。&lt;/p&gt;

&lt;p&gt;单页应用的流行程度正在逐渐增加，大家如果关注了一些初创型互联网企业，会发现其中很大一部分的产品模式是单页化的。这种模式能带给用户流畅的体验，在开发阶段，对JavaScript技能水平要求较高。&lt;/p&gt;

&lt;p&gt;单页应用开发过程中，前后端是天然分离的，双方以API为分界。前端作为服务的消费者，后端作为服务的提供者。在此模式下，前端将会推动后端的服务化。当后端不再承担模板渲染、输出页面这样工作的情况下，它可以更专注于所提供的API的实现，而在这样的情况下，Web前端与各种移动终端的地位对等，也逐渐使得后端API不必再为每个端作差异化设计了。&lt;/p&gt;

&lt;p&gt;部署模式的改变&lt;/p&gt;

&lt;p&gt;在现在这个时代，我们已经可以看到一种产品的出现了，那就是“无后端”的Web应用。这是一种什么东西呢？基于这种理念，你的产品很可能只需要自己编写静态Web页面，在某种BaaS（Backend as a Service）云平台上定制服务端API和云存储，集成这个平台提供的SDK，通过AJAX等方式与之打交道，实现注册认证、社交、消息推送、实时通信、云存储等功能。&lt;/p&gt;

&lt;p&gt;我们观察一下这种模式，会发现前后端的部署已经完全分离了，前端代码完全静态化，这意味着可以把它们放置到CDN上，访问将大大地加速，而服务端托管在BaaS云上，开发者也不必去关注一些部署方面的繁琐细节。&lt;/p&gt;

&lt;p&gt;假设你是一名创业者，正在做的是一种实时协同的单页产品，可以在云平台上，快速定制后端服务，把绝大部分宝贵的时间花在开发产品本身上。&lt;/p&gt;

&lt;p&gt;单页应用的缺陷&lt;/p&gt;

&lt;p&gt;单页应用最根本的缺陷就是不利于SEO，因为界面的绝大部分都是动态生成的，所以搜索引擎很不容易索引它。&lt;/p&gt;

&lt;p&gt;产品单页化带来的挑战&lt;/p&gt;

&lt;p&gt;一个产品想要单页化，首先是它必须适合单页的形态。其次，在这个过程中，对开发模式会产生一些变更，对开发技能也会有一些要求。&lt;/p&gt;

&lt;p&gt;开发者的JavaScript技能必须过关，同时需要对组件化、设计模式有所认识，他所面对的不再是一个简单的页面，而是一个运行在浏览器环境中的桌面软件。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>angular的问题</title>
      <link>https://satisfied1.github.io/post/angular%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 08 Dec 2016 11:12:41 +0800</pubDate>
      
      <guid>https://satisfied1.github.io/post/angular%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;Angular的问题&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.quirksmode.org/blog/archives/2015/01/the_problem_wit.html&#34; alt=&#34;原文地址&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在过去半年里，我跟一些潜在客户进行了交谈，他们在寻找前端顾问来帮助开发团队控制Angular项目的时候，遇到了麻烦。&lt;/p&gt;

&lt;p&gt;尽管有一些对Angular很热情的前端人员，我有种感觉，对于一个主流框架来说，他们的数量还是太少了。我期望Angular能比之前受到更多关注。&lt;/p&gt;

&lt;p&gt;Angular更多地是面向企业的IT部门，而不是前端人员。它独特的编码风格，它那种更倾向服务端而不是浏览器侧的对HTML模板系统的封装形式，以及严重而基础的性能问题吓跑了不少人。&lt;/p&gt;

&lt;p&gt;我曾经说过，Angular更多的用户是有Java背景的人员，因为它的编码风格是面向他们的。不幸的是，他们没有被培训以认识到Angular的性能问题。&lt;/p&gt;

&lt;p&gt;对于Angular 1.x是否适合现代web开发，我表示怀疑。如果有人持有不太客气的倾向，他会把它描述成一个：非前端人员做给非前端人员用的前端框架。&lt;/p&gt;

&lt;p&gt;Angular 2.0被提出了激进的改写，意图使它更符合前端人员的口味，但我怀疑他们所感兴趣的是另外一个MVC框架了。此外，重写有可能会疏远Angular的当前目标受众。&lt;/p&gt;

&lt;p&gt;如果你想要知道为什么我有这些想法，恐怕要把这篇长文章看完了。&lt;/p&gt;

&lt;p&gt;Angular 服务页面&lt;/p&gt;

&lt;p&gt;我感觉到Angular的基本理念在前后端之间模糊不清。看一看这个示例代码吧，这是我拉过来的真实的东西:&lt;/p&gt;

&lt;p&gt;&lt;body&gt;
  &lt;h2&gt;Todo&lt;/h2&gt;
  &lt;div ng-controller=&#34;TodoController&#34;&gt;
    &lt;span&gt;{{remaining()}} of {{todos.length}} remaining&lt;/span&gt;
    [ &lt;a href=&#34;&#34; ng-click=&#34;archive()&#34;&gt;archive&lt;/a&gt; ]
    &lt;ul class=&#34;unstyled&#34;&gt;
      &lt;li ng-repeat=&#34;todo in todos&#34;&gt;
        &lt;input type=&#34;checkbox&#34; ng-model=&#34;todo.done&#34;&gt;
        &lt;span class=&#34;done-{{todo.done}}&#34;&gt;{{todo.text}}&lt;/span&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
    &lt;form ng-submit=&#34;addTodo()&#34;&gt;
      &lt;input type=&#34;text&#34; ng-model=&#34;todoText&#34;  size=&#34;30&#34;
             placeholder=&#34;add new todo here&#34;&gt;
      &lt;input class=&#34;btn-primary&#34; type=&#34;submit&#34; value=&#34;add&#34;&gt;
    &lt;/form&gt;
  &lt;/div&gt;
&lt;/body&gt;
这代码让我想起了一个简单的服务端脚本语言，比如JSP或者ASP，它们使用数据库的内容来填充HTML模板。这些语言在web开发栈中有一席之地——但是在服务端，而不是浏览器端。&lt;/p&gt;

&lt;p&gt;上个月，我在一个大型的荷兰公司参与了项目，它们庞大的网站使用了各种小部件和设计模式，做相同的事情，但不是来源于通用的代码库，整个网站间充斥复制／粘贴。这显然是个不受欢迎的状况。&lt;/p&gt;

&lt;p&gt;他们转向Angular以解决这个问题，包括把所需的部件集中化。虽然模板是正确的解决方案，在浏览器中这么做却是根本错误的。应用程序维护的成本不应转移到所有用户的浏览器（在这里，我们所讨论的是每个月数以百万计的点击）中——尤其它们不是移动浏览器。这个事情是属于服务端的。&lt;/p&gt;

&lt;p&gt;严格来说，这不是Angular的问题，而是这个公司使用Angular进行的实现所致。然而，从逻辑上讲，是Angular，在所有JavaScript 框架中，把这个问题更深化了。它的类似JSP的品质，允许了，甚至鼓励了这种行为。&lt;/p&gt;

&lt;p&gt;Angular 的目标受众&lt;/p&gt;

&lt;p&gt;Angular是面向大型企业的IT后端和经理们的，他们被JavaScipt疯狂扩散的工具们搞迷糊了。在一篇优秀的文章中，Andrew Austin描述了在企业IT中Angular的状况：&lt;/p&gt;

&lt;p&gt;对整个团队都属于Google的AngularJS团队，有很多积极的看法。首先，有商业实体控制的框架通常是比较积极的，因为它完全避免了政治派系之间的斗争。在开源世界，这种内讧是公开的，严重的，影响到团队构建伟大软件的目标。
企业IT经理们想要背后有一个大公司良好维护的代码，这样他们不用担心突然就得不到支持了。此外，Google在web技术方面名声较好，所以，如果他们推出一个JavaScript库，那必须是非常好啊……是不是？&lt;/p&gt;

&lt;p&gt;企业IT经理也喜欢这么一个事实：Angular对后端开发人员友好。我用Twitter跟weather.com的Joe Pearson进行了讨论，他告诉我，最近转向Angular，主要是为了Java开发人员。Angular所使用的代码构建方式很适合他们，但对他们的前端人员却并非如此。从我客户那里得到的消息，是他们的Java开发人员决定使用Angular。&lt;/p&gt;

&lt;p&gt;换句话说，Angular出了吸引经理们，还打动了Java开发人员。框架与恰当的应用程序结构概念相结合，一切都不是意外。Google的目标是征服企业市场，Angular是它的工具之一。&lt;/p&gt;

&lt;p&gt;另一方面，很多前端人员，在JavaScript和浏览器上面花了很多年，已经拥有了自己的编码风格，倾向于对Angular表示怀疑。&lt;/p&gt;

&lt;p&gt;这本身不是个问题：人们应当使用适合自己编码风格的框架。不幸的是，Angular的问题太深了。&lt;/p&gt;

&lt;p&gt;性能问题&lt;/p&gt;

&lt;p&gt;再看一眼Angular的示例代码吧：&lt;/p&gt;

&lt;p&gt;&lt;body&gt;
  &lt;h2&gt;Todo&lt;/h2&gt;
  &lt;div ng-controller=&#34;TodoController&#34;&gt;
    &lt;span&gt;{{remaining()}} of {{todos.length}} remaining&lt;/span&gt;
    [ &lt;a href=&#34;&#34; ng-click=&#34;archive()&#34;&gt;archive&lt;/a&gt; ]
    &lt;ul class=&#34;unstyled&#34;&gt;
      &lt;li ng-repeat=&#34;todo in todos&#34;&gt;
        &lt;input type=&#34;checkbox&#34; ng-model=&#34;todo.done&#34;&gt;
        &lt;span class=&#34;done-{{todo.done}}&#34;&gt;{{todo.text}}&lt;/span&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
    &lt;form ng-submit=&#34;addTodo()&#34;&gt;
      &lt;input type=&#34;text&#34; ng-model=&#34;todoText&#34;  size=&#34;30&#34;
             placeholder=&#34;add new todo here&#34;&gt;
      &lt;input class=&#34;btn-primary&#34; type=&#34;submit&#34; value=&#34;add&#34;&gt;
    &lt;/form&gt;
  &lt;/div&gt;
&lt;/body&gt;
在{{}}中的所有代码段都是Angular语句。问题在于，Angular无法发现这些语句，除非解析整个DOM，包括文本阶段和属性值——这过程的开销太大了，特别在移动端。&lt;/p&gt;

&lt;p&gt;虽然对于整体性能而言，这不一定是致命的问题，解析整个DOM所花费的时间是需要作为一个问题被指出的。不幸的是，这种性能似乎被Angular所代表的整体所忽略了。&lt;/p&gt;

&lt;p&gt;Filament Group的测试报告对Angular来说，不太乐观。尽管作者非常小心地提到，对一个大型、复杂的应用做测试，结果可能更积极些，他们的简单测试应用的Angular版本表现并不好。Ember的也不好，只有Backbone脱颖而出。&lt;/p&gt;

&lt;p&gt;Steven Czerwinksi提供了有趣的细节：&lt;/p&gt;

&lt;p&gt;每次更新都花费了一段较长时间来创建和销毁DOM元素。如果新视图有不同的行数，或者任何一行的单词数量不同，Angular的ng-repeat指令都会整体创建或销毁DOM元素。这个开销很大。
尽管这篇文章展示了如何简单地解决这个问题，我担心的是，Angular默认的就是这种性能低下的模式。前端框架默认应当使用前端建立的最佳实践。但Angular没有。&lt;/p&gt;

&lt;p&gt;即使是Google，似乎也同意它有问题了。在对Angular的批评中，最能让我感到共鸣的文章是来自Daniel Steigerwald 写的Angular.js有什么问题的：&lt;/p&gt;

&lt;p&gt;Google不把Angular用在自己的标志产品比如Gmail或Gplus上。
哎，你要吃你自己的狗粮哎。&lt;/p&gt;

&lt;p&gt;对于一个普通水平的，只拥有少量前端知识的后端人员来说，这些问题是看不到的。这个框架如它宣传的那样运作，它来自一个在前端技术领域拥有声望的公司，所以，普通水平的后端人员就会默认：这就是前端世界的做事方式。&lt;/p&gt;

&lt;p&gt;Angular的方式&lt;/p&gt;

&lt;p&gt;对很多前端人员而言，最大的问题是，Angular强迫自己用一种指定的方式去干活。Software Improvement Group发布了一份报告指出（我的强调）：&lt;/p&gt;

&lt;p&gt;使用AngularJS给开发人员提供了一堆好处。……这些好处为AngularJS的流行作出了贡献，当遵守AngularJS的约定时，生产力会更高。
这份报告把这个问题当作了优点，而不是缺点。在一份自认为带个人倾向的JS框架纲要中，Henrik Joreteg的观念就比较负面了：&lt;/p&gt;

&lt;p&gt;选择Angular意味着你学习的是如何用Angular这个框架，而不是用JavaScript来解决问题。……我有些开发人员，他们的主要技能是Angular，而不是JavaScript。
因为有必要学习使用Angular的方式去处理事情，这个框架的学习曲线很陡峭。Ben Nadel，一个Angular爱好者，而不是一个反对者，把这个事情可视化了：&lt;/p&gt;

&lt;p&gt;换句话说，Angular需要你花很多时间来学习如何使用Angular的方式来做事，有些人会喜欢这样，但另外一些会视之为一种额外负担，对其敬而远之。&lt;/p&gt;

&lt;p&gt;哪里不对&lt;/p&gt;

&lt;p&gt;这些为什么是问题呢？Angular哪里不对呢？Rob Eisenberg 给出了一个解释：&lt;/p&gt;

&lt;p&gt;差不多五年前，当AngularJS刚创建出来的时候，它并不是给开发人员用的。它是一个工具，更倾向于给需要快速创建持久化HTML表单的设计人员用。随着时间推移，它作了改变以适应各种场景，开发人员也用它建造更多、更复杂的应用程序。
关于Angular历史的更多东西，参见Hacker News这个帖子。&lt;/p&gt;

&lt;p&gt;我不认为，一个快速原型工具应当被用于复杂的，企业级的生产代码上。&lt;/p&gt;

&lt;p&gt;这还没完。同一篇文章中给了另一个担忧的原因：&lt;/p&gt;

&lt;p&gt;虽然Angular可以被用于创建移动应用，但它的理念并非为它们设计的。这包括了所有的东西，从我刚提到过的基本的性能问题，到它的路由的能力缺失，以及不能缓存预编译视图，甚至是过于普通的触摸支持。
这个只有5岁大的框架没有为移动端做有效优化，很不可理喻。回到2010年，移动也不是个问题。&lt;/p&gt;

&lt;p&gt;不过，我们应该看的不是2010，而是2012年。我记得最早，Google开始推广Angular是2012年中。（这个日期有2012年6月的这篇文章为证，我觉得这可能是最早提到Angular的一篇了）。&lt;/p&gt;

&lt;p&gt;在那个时候，Android对Google的未来至关重要，这事已经很明朗了，所以你在推的这个工具要支持你未来的平台，这很重要……是不是？&lt;/p&gt;

&lt;p&gt;我想知道，当推出这么一个框架，初衷不是帮助开发人员，包含严重DOM性能问题，未对自家移动平台作优化，这个时候，Google到底在想什么。&lt;/p&gt;

&lt;p&gt;Right hand, meet left hand.&lt;/p&gt;

&lt;p&gt;Angular与前端&lt;/p&gt;

&lt;p&gt;别误会：有些前端人员是热衷于的，也存在模块仓库和最佳实践的站点。&lt;/p&gt;

&lt;p&gt;我的观点是，我期望有更多前端人员拥抱Angular。我有种感觉，它们的数量少得吓人——看看我的客户们的那些问题，他们找个好的Angular前端顾问有多么难。怎么会这样的呢？&lt;/p&gt;

&lt;p&gt;部分的答案是：可能因为Angular设计得更迎合Java开发人员的口味，而不是JavaScript开发人员。这使得前端人员不易接受。不过，编码风格并不是绑死语言的，所以这不是完整的答案。&lt;/p&gt;

&lt;p&gt;更重要的原因可能是JavaScript社区的拖后腿。Angular引发了一些严重指责。Alexey Migutsky总结得最好：&lt;/p&gt;

&lt;p&gt;Angular.js对大多数项目来说“够好”了，但对于专业Web应用开发（长期维护，在所有现代浏览器上性能可靠，有平滑的UX，对移动设备友好）来说，还是不够好。
我认为他是有发言权的。我在本文中所总结的长篇控诉，特别是性能问题，让我怀疑Angular 1.x能不能适合现代前端工程。Angular要么是一个非前端人员创建的，给非前端人员用的框架，要么是把自己的前端特征藏得太好了。&lt;/p&gt;

&lt;p&gt;这也就是为什么我认为在本文的开始引用过的Andrew Austin，当他这么陈述的时候错了：&lt;/p&gt;

&lt;p&gt;对一个组织来说，相比雇用jQuery开发人员，雇用AngularJS开发人员可能更难。……但是不要担心，日子一天一天过，越来越多的JavaScript开发人员会发现AngularJS的，他们会用它来创建真正的应用。……相比于雇用有AngularJS经验的开发人员，培训已有的团队，或者雇用那些对学习AngularJS有兴趣的JavaScript多面手会更加容易些。
对于一个前端人员，习惯于用特定方式来做事，迁移到Angular的方式可能比较痛苦。此外，他们反对Angular所导致的性能问题。Angular对前端的敏感点迎合得不够，所以很多前端倾向于无视它。&lt;/p&gt;

&lt;p&gt;后端们就没这么麻烦了。他们没有先入为主的前端代码应当如何写的概念，不经过培训的话，也认识不到Angular的性能问题。&lt;/p&gt;

&lt;p&gt;我的荷兰客户提到一个事情，加剧了这个问题：一般来说，前端开发者不喜欢企业级应用（企业IT流程，无尽的会议，为了解决简单的问题花很多周，这些的简称），因为它被视为无聊。这导致了前端Angular开发者和顾问更少了。&lt;/p&gt;

&lt;p&gt;这也就是为什么多数Angular开发人员来自后端，特别是Java。据我所知，一个前端框架主要由非前端开发者来支撑的情况是独此一家的。&lt;/p&gt;

&lt;p&gt;Angular 2.0&lt;/p&gt;

&lt;p&gt;对于提到的这些抱怨和问题的总结，Angular团队并未装聋作哑。在10月的时候，他们宣布了Angular 2.0，这是对1.x的完全背离。为了能上新版本，Angular用户将不得不重新编写网站代码。&lt;/p&gt;

&lt;p&gt;为什么需要这么激进的变更呢，很容易理解。为了给Angular一个重大性能提升，需要抛弃启动时候解析{{}}DOM的开销。为了这么做，语法必须改变，这会对开发过程造成严重后果。我想说，Angular 2.0需要开发人员在HTML模板中嵌入更少的应用逻辑，更多地放在脚本中。&lt;/p&gt;

&lt;p&gt;我认为，这种激进的重写基本是瞄准前端人员的，他们将获得更好的性能，更符合自己对JavaScript框架预期的语法。&lt;/p&gt;

&lt;p&gt;然而，这带来最大的代价就是会疏远最大的用户群体。企业IT选择Angular，期望能幸免于这样突然，关键的变化。采用Angular2.0会需要他们重新分配预算来重写已经在运行的代码。此外，我想知道有Java背景的人怎样看待新代码风格。&lt;/p&gt;

&lt;p&gt;基于这些原因，我认为很多企业用户会坚守1.x，无视2.0。当然，Google最终会停止支持1.x的。因此，我认为Google想要使用Angular打破企业级前端的堡垒，在最近两三年内还是不会成功的。&lt;/p&gt;

&lt;p&gt;虽然企业IT的背叛可以被前端人员的青睐所抵消，但Angular从此在他们心中印象就不好了。此外，前端界现在也不需要另外一个MVC框架。&lt;/p&gt;

&lt;p&gt;尽管有严重的技术问题，Angular 1.x还是一个较大的成功，尤其是在拥有Java背景的企业开发人员中。2.0的重写是瞄准前端开发人员的，但不会对他们有太多好处，反而会失去一些当前的拥趸。我不认为Angular的新版能生存下去。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>angular性能优化</title>
      <link>https://satisfied1.github.io/post/angular%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
      <pubDate>Thu, 08 Dec 2016 11:11:26 +0800</pubDate>
      
      <guid>https://satisfied1.github.io/post/angular%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
      <description>&lt;p&gt;优化Angular应用的性能&lt;/p&gt;

&lt;p&gt;MVVM框架的性能，其实就取决于几个因素：&lt;/p&gt;

&lt;p&gt;监控的个数
数据变更检测与绑定的方式
索引的性能
数据的大小
数据的结构
我们要优化Angular项目的性能，也需要从这几个方面入手。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;减少监控值的个数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;监控值的个数怎么减少呢？&lt;/p&gt;

&lt;p&gt;考虑极端情况，在不引入Angular的时候，监控的个数是为0的，每当我们有需要绑定的数据项，就产生了监控值。&lt;/p&gt;

&lt;p&gt;我们注意到，Angular里面使用了一种HTML模板语法来做绑定，开发业务项目非常方便，但考虑一下，这种所谓的“模板”，其实与我们常见的那种模板是不同的。&lt;/p&gt;

&lt;p&gt;传统的模板，是静态模板，将数据代入模板之后生成界面，之后数据再有变化，界面也不会变。但Angular的这种“模板”是动态的，当界面生成完毕，数据产生变更的时候，界面还是会更新。&lt;/p&gt;

&lt;p&gt;这是Angular的优势，但我们有时候也会因为使用不当，反而增加困扰。因为Angular采用了变动检测的方式来跟踪数据的变化，这些事情都是有负担的，很多时候，有些数据在初始化之后就不再会变化，但因为我们没有把它们区分出来，Angular还是要生成一个监听器来跟踪这部分数据的变化，性能也就受到牵累。&lt;/p&gt;

&lt;p&gt;在这种情况下，可以采用单次绑定，仅在初始化的时候把这些数据绑定，语法如下：&lt;/p&gt;

&lt;p&gt;&lt;div&gt;{{::item}}&lt;/div&gt;
&lt;ul&gt;&lt;br /&gt;
  &lt;li ng-repeat=&#34;item in ::items&#34;&gt;{{item}}&lt;/li&gt;
&lt;/ul&gt;
这样的数据就不会被持续观测，也就有效减少了监控值的数目，提高了性能。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;降低数据比对的开销&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这一个环节是从数据变更检测与绑定的方式入手。细节不说太多了，之前都说过。从数据到界面的更新，一般就两种方式：推、拉。&lt;/p&gt;

&lt;p&gt;所谓推，就是在set的时候，主动把与之相关的数据更新，大部分框架是这种方式，低版本浏览器用defineSetter之类。&lt;/p&gt;

&lt;p&gt;function Employee() {
    this._firstName = &amp;ldquo;&amp;rdquo;;
    this._lastName = &amp;ldquo;&amp;rdquo;;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.fullName = &amp;quot;&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;Employee.prototype = {
    get firstName(){
        return this._firstName;
    },
    set firstName(val){
        this._firstName = val;
        this.fullName = val + &amp;ldquo; &amp;rdquo; + this.lastName;
    },
    get lastName(){
        return this._lastName;
    },
    set lastName(val){
        this._lastName = val;
        this.fullName = this.lastName + &amp;ldquo; &amp;rdquo; + val;
    }
};
所谓拉，就是set的时候只改变自己，关联数据等到用的时候自己去取。比如：&lt;/p&gt;

&lt;p&gt;function Employee() {
    this.firstName = &amp;ldquo;&amp;rdquo;;
    this.lastName = &amp;ldquo;&amp;rdquo;;
}&lt;/p&gt;

&lt;p&gt;Employee.prototype = {
    get fullName() {
        return this.firstName + &amp;ldquo; &amp;rdquo; + this.lastName;
    }
};
有些框架中，两种方式都可以用。这时候可以自己考虑下适合用哪种方式，比如说，可能有些框架是合并变更，批量更新的，可能就用拉的方式效率高；有些框架是实时变动，差异更新的，那可能就是用推的效率高些。&lt;/p&gt;

&lt;p&gt;上面的代码能看出来，从代码编写的简洁性来说，拉模式要比推模式简单很多，如果能预知数据量较小，可以这样用。&lt;/p&gt;

&lt;p&gt;在实际开发过程中，这两种方式是需要权衡的。我们举的这个例子比较简单，如果说某个属性依赖于很多东西，例如，一个很大的购物列表，有个总价，它是由每个商品的单价乘以购买个数，再累加起来的。&lt;/p&gt;

&lt;p&gt;在这种情况下，如果使用拉模式，也就是在总价的get上做这个变动，它需要遍历整个数组，重新作计算。但是如果使用推模式，每次有商品价格或者商品购买个数发生变更的时候，都只要在原先的总价上，减去两次变动的差价即可。&lt;/p&gt;

&lt;p&gt;此外，不同的框架用不同方式来检测数据的变动，比如Angular，如果有一个数组中的元素发生变化了，它是怎样知道这个数组变了呢？&lt;/p&gt;

&lt;p&gt;它需要保持变动之前的数据，然后作比对：&lt;/p&gt;

&lt;p&gt;首先比对数组的引用是否相等，这一步是为了检测数组的整体赋值，比如this.arr = [1, 2, 3]; 直接把原来的替换掉了，如果出现这种情况，就认为它肯定变化了。（其实，如果内容与原先相同，是可以认为没有变的，但因为这些框架的内部实现，往往都需要更新数据与DOM元素的索引关系，所以不能这样）
其次，比较数组的长度，如果长度跟原先不相等了，那肯定也产生变化了
然后只能挨个去比对里面元素的变化了
所以，会有人考虑在Angular中结合immutable这样的东西，加速变更的判定过程，因为immutable的数据只要发生任何变化，其引用都一定会变，所以只要第一步判定引用就足以知道数据是否改变了。&lt;/p&gt;

&lt;p&gt;有人说，你这个判定降低的开销并不大啊，因为引入immutable要增加复制的开销，跟这里的新旧数据比对开销相比，也低不到哪里去。但这个地方要注意，Angular在有事件产生的时候，会把所有监控数据都重新比对，也就是说，如果你在界面上有个大数组，你从未对它重新赋值，而是经常在另外一个很小的表单项绑定的数据上进行更新，这个数组也是要被比对的，这就比较坑了，所以如果引入immutable，可以大幅降低平时这种不受影响时候的比对成本。&lt;/p&gt;

&lt;p&gt;但是引入immutable也会对整个应用造成影响，需要在每个赋值取值的地方都使用immutable的封装方式，而且还要在绑定的时候，对数据作解包，因为Angular绑定的数据是pojo。&lt;/p&gt;

&lt;p&gt;所以，用这种方式还是要慎重，除非框架自身就构建在immutable的基础上。或许，我们可以期望有一套与ng-model平行的机制，ng-immutable之类，实现的难度也还是挺大的。&lt;/p&gt;

&lt;p&gt;在使用ES5的场景下，可以利用一些方法加速判断，比如数组的：&lt;/p&gt;

&lt;p&gt;filter
map
reduce
它们能够返回一个全新的数组，与原先的引用不等，所以在第一步判断就可以得出结果，不必继续后面几步的比较。&lt;/p&gt;

&lt;p&gt;不过，这个环节的优化其实很不明显，最关键的优化在于与之配套的索引优化，参见下一节。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;提升索引的性能&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在Angular中，可以通过ng-repeat来实现对数组或者对象的遍历，但这个遍历的机制，其实有很多技巧。&lt;/p&gt;

&lt;p&gt;在使用简单类型数组的时候，我们很可能会碰到这么一个问题：数组中存在相同的值，比如：&lt;/p&gt;

&lt;p&gt;this.arr = [1, 3, 5, 3];
&lt;ul&gt;
    &lt;li ng-repeat=&#34;num in arr&#34;&gt;{{num}}&lt;/li&gt;
&amp;lt;/ul
这时候会报错，然后如果去搜索一下，会发现一个解决方式：&lt;/p&gt;

&lt;p&gt;&lt;ul&gt;
    &lt;li ng-repeat=&#34;num in arr track by $index&#34;&gt;{{num}}&lt;/li&gt;
&amp;lt;/ul
为什么这就能解决呢？&lt;/p&gt;

&lt;p&gt;我们先思考一下，如果自己实现类似Angular这样的功能，因为要在DOM和数据之间建立关联，这样，当改变数据的时候，才能刷新到对应的界面，所以，必然有个映射关系。&lt;/p&gt;

&lt;p&gt;映射关系需要唯一的索引，在刚才那个例子中，Angular默认对简单类型使用自身当索引，当出现重复的时候，就会出错了。如果指定$index，也就是元素在数组中的下标为索引，就可以避免这个问题。&lt;/p&gt;

&lt;p&gt;那么，对于对象数组，又是怎样呢？&lt;/p&gt;

&lt;p&gt;比如说这么一个数组，我们用不同的两个方式来绑定：&lt;/p&gt;

&lt;p&gt;function ListCtrl() {
    this.arr = [];
    for (var i=0; i&amp;lt;10000; i++) {
        this.arr.push({
            id: i,
            label: &amp;ldquo;Item &amp;rdquo; + i
        });
    }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var time = new Date();
$timeout(function() {
    alert(new Date() - time);
    console.log(this.arr[0]);
}.bind(this), 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
&lt;ul ng-controller=&#34;ListCtrl as listCtrl&#34;&gt;
    &lt;li ng-repeat=&#34;item in listCtrl.arr&#34;&gt;{{item}}&lt;/li&gt;
&lt;/ul&gt;
&lt;ul ng-controller=&#34;ListCtrl as listCtrl&#34;&gt;
    &lt;li ng-repeat=&#34;item in listCtrl.arr track by item.id&#34;&gt;{{item}}&lt;/li&gt;
&lt;/ul&gt;
看示例地址，多点击几下：&lt;/p&gt;

&lt;p&gt;我们惊奇地发现，这两个时间有不小差别。&lt;/p&gt;

&lt;p&gt;关注一下在绑定之后，arr里面的数据，发现在没有加track by $index的时候，原始数据被改变了，添加了一些索引信息，这些索引是当数据产生变更时，Angular能够找到关联界面的重要线索。&lt;/p&gt;

&lt;p&gt;Object {id: 0, label: &amp;ldquo;Item 0&amp;rdquo;, $$hashKey: &amp;ldquo;object:4&amp;rdquo;}
如果我们知道数据的唯一性由什么保证，并且手动指定其为索引，可以减少不必要的添加索引的过程。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;降低数据的大小&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看到这个标题，可能有人会感到奇怪。业务数据的大小并不是由程序员控制的，怎么降低呢？这里的降低，指的是降低那些被用于绑定到界面的数据大小。&lt;/p&gt;

&lt;p&gt;数据的大小也会影响绑定效率，我们考虑一个屏幕能展示的数据有限，并不需要把所有东西都立即展示出来，可以从数据中截取一段进行展示，比如大家都熟悉的数据分页就是这么一种方式。&lt;/p&gt;

&lt;p&gt;很传统的那种数据分页，是会有一个分页条，上面写着总共多少数据，然后上一页，下一页，这样切换。后来出现了一些变种，比如滚动加载，当滚动条滚到底部的时候，再去加载或生成新的界面。&lt;/p&gt;

&lt;p&gt;如果说，我们有上万条数据形成的一个列表，但是又不打算用那么老圡的方式放个分页条在下面，如何在性能与体验中取得一个平衡呢？&lt;/p&gt;

&lt;p&gt;接触过Adobe Flex的人，可能会对其中的列表控件印象深刻，因为就算你给它上百万数据，它也不会因此而慢下来，为什么呢？因为它的滚动条是假的。&lt;/p&gt;

&lt;p&gt;同理，我们也可能在浏览器中使用DOM来模拟一个滚动条，然后利用这个滚动条的位置，从全量数据中获取对应的那一段数据，并且绑定渲染到界面上。&lt;/p&gt;

&lt;p&gt;这种技术一般称为Virtual List，在很多框架中都有第三方实现，可以参见这篇文章：AngularJS virtual list directive tutorial&lt;/p&gt;

&lt;p&gt;上面这篇文章做到的，只是初步的优化，并不精细，因为它假定列表中所有项的大小是一致的，而且要在创建阶段即已预知，这样就很不灵活了。如果需要做更精细的优化，需要做实时的度量，对每个已创建并渲染的子项作度量，然后以此来更新滚动区的位置。&lt;/p&gt;

&lt;p&gt;参见demo：&lt;a href=&#34;http://codepen.io/xufei/pen/avRjqV&#34;&gt;http://codepen.io/xufei/pen/avRjqV&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将数据的结构扁平化&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那么，数据的结构又是怎样影响到执行效率的呢？我举一个常见的例子就是树形结构，这个结构一般人会使用ul和li之类的结构做，然后不可避免地要用递归的方式来使用MVVM框架。&lt;/p&gt;

&lt;p&gt;我们考虑一下，为什么非要使用这种方式呢？其原因有二：&lt;/p&gt;

&lt;p&gt;给定的数据结构就是树形的
我们习惯于使用树形DOM结构来表达树形数据
这个树形数据对我们来说，是什么？是数据模型。但是我们知道，比对两个树形结构是很麻烦的，它的层级使得监控变得复杂，无论是数据的逐一比对，还是存取器、或者刚被取消的observe提案，都会比单层数据麻烦很多。&lt;/p&gt;

&lt;p&gt;如果我们想要用一种更加扁平的DOM结构来展示它，而不是层级结构，怎么办呢？所谓的树形DOM结构，能展现给我们的无非是位置的偏移，比如所有下级节点比上级更靠右，这些东西其实可以很轻易使用定位来模拟，这么一来，就有可能适用平级DOM结构来表达树的形状了。&lt;/p&gt;

&lt;p&gt;回忆一下，MVVM，这几个字母什么意思？&lt;/p&gt;

&lt;p&gt;Model View ViewModel&lt;/p&gt;

&lt;p&gt;我们看了前两者了，但从未关注过视图模型。在很多人眼里，视图模型只是模型的一个简单封装，其实那只是特例，Angular官方的demo形成了这种误导。视图模型的真正作用应当包括：把模型转化为适合视图展示的格式。&lt;/p&gt;

&lt;p&gt;如果说我们需要在视图层有比较扁平的数据结构，就必须在这一层把原始数据拍扁，举个栗子，我们要做一个动态的组织架构图，这个展开会像一个树，内部肯定也会有树形的数据结构，但我们可以同时维护树形和扁平的两种结构，并且随时保持同步：&lt;/p&gt;

&lt;p&gt;原始数据如下：&lt;/p&gt;

&lt;p&gt;var source = [
    {id: &amp;ldquo;0&amp;rdquo;, name: &amp;ldquo;a&amp;rdquo;},
    {id: &amp;ldquo;1&amp;rdquo;, name: &amp;ldquo;b&amp;rdquo;},
    {id: &amp;ldquo;013&amp;rdquo;, name: &amp;ldquo;abd&amp;rdquo;, parent: &amp;ldquo;01&amp;rdquo;},
    {id: &amp;ldquo;2&amp;rdquo;, name: &amp;ldquo;c&amp;rdquo;},
    {id: &amp;ldquo;3&amp;rdquo;, name: &amp;ldquo;d&amp;rdquo;},
    {id: &amp;ldquo;00&amp;rdquo;, name: &amp;ldquo;aa&amp;rdquo;, parent: &amp;ldquo;0&amp;rdquo;},
    {id: &amp;ldquo;01&amp;rdquo;, name: &amp;ldquo;ab&amp;rdquo;, parent: &amp;ldquo;0&amp;rdquo;},
    {id: &amp;ldquo;02&amp;rdquo;, name: &amp;ldquo;ac&amp;rdquo;, parent: &amp;ldquo;0&amp;rdquo;},
    {id: &amp;ldquo;010&amp;rdquo;, name: &amp;ldquo;aba&amp;rdquo;, parent: &amp;ldquo;01&amp;rdquo;},
    {id: &amp;ldquo;011&amp;rdquo;, name: &amp;ldquo;abb&amp;rdquo;, parent: &amp;ldquo;01&amp;rdquo;},
    {id: &amp;ldquo;012&amp;rdquo;, name: &amp;ldquo;abc&amp;rdquo;, parent: &amp;ldquo;01&amp;rdquo;}
];
转换代码如下：&lt;/p&gt;

&lt;p&gt;var map = {};
var dest = [];&lt;/p&gt;

&lt;p&gt;source.forEach(function(it) {
    map[it.id] = it;
});&lt;/p&gt;

&lt;p&gt;source.forEach(function(it) {
    if (！it.parent) {
        //根节点
        dest.push(it);
    }
    else {
        //叶子节点
        map[it.parent].children = map[it.parent].children || [];
        map[it.parent].children.push(it);
    }
});
转换之后的dest变成了这样：&lt;/p&gt;

&lt;p&gt;[
    {
        &amp;ldquo;id&amp;rdquo;: &amp;ldquo;0&amp;rdquo;,
        &amp;ldquo;name&amp;rdquo;: &amp;ldquo;a&amp;rdquo;,
        &amp;ldquo;children&amp;rdquo;: [
            {
                &amp;ldquo;id&amp;rdquo;: &amp;ldquo;00&amp;rdquo;,
                &amp;ldquo;name&amp;rdquo;: &amp;ldquo;aa&amp;rdquo;,
                &amp;ldquo;parent&amp;rdquo;: &amp;ldquo;0&amp;rdquo;
            },
            {
                &amp;ldquo;id&amp;rdquo;: &amp;ldquo;01&amp;rdquo;,
                &amp;ldquo;name&amp;rdquo;: &amp;ldquo;ab&amp;rdquo;,
                &amp;ldquo;parent&amp;rdquo;: &amp;ldquo;0&amp;rdquo;,
                &amp;ldquo;children&amp;rdquo;: [
                    {
                        &amp;ldquo;id&amp;rdquo;: &amp;ldquo;013&amp;rdquo;,
                        &amp;ldquo;name&amp;rdquo;: &amp;ldquo;abd&amp;rdquo;,
                        &amp;ldquo;parent&amp;rdquo;: &amp;ldquo;01&amp;rdquo;
                    },
                    {
                        &amp;ldquo;id&amp;rdquo;: &amp;ldquo;010&amp;rdquo;,
                        &amp;ldquo;name&amp;rdquo;: &amp;ldquo;aba&amp;rdquo;,
                        &amp;ldquo;parent&amp;rdquo;: &amp;ldquo;01&amp;rdquo;
                    },
                    {
                        &amp;ldquo;id&amp;rdquo;: &amp;ldquo;011&amp;rdquo;,
                        &amp;ldquo;name&amp;rdquo;: &amp;ldquo;abb&amp;rdquo;,
                        &amp;ldquo;parent&amp;rdquo;: &amp;ldquo;01&amp;rdquo;
                    },
                    {
                        &amp;ldquo;id&amp;rdquo;: &amp;ldquo;012&amp;rdquo;,
                        &amp;ldquo;name&amp;rdquo;: &amp;ldquo;abc&amp;rdquo;,
                        &amp;ldquo;parent&amp;rdquo;: &amp;ldquo;01&amp;rdquo;
                    }
                ]
            },
            {
                &amp;ldquo;id&amp;rdquo;: &amp;ldquo;02&amp;rdquo;,
                &amp;ldquo;name&amp;rdquo;: &amp;ldquo;ac&amp;rdquo;,
                &amp;ldquo;parent&amp;rdquo;: &amp;ldquo;0&amp;rdquo;
            }
        ]
    },
    {
        &amp;ldquo;id&amp;rdquo;: &amp;ldquo;1&amp;rdquo;,
        &amp;ldquo;name&amp;rdquo;: &amp;ldquo;b&amp;rdquo;
    },
    {
        &amp;ldquo;id&amp;rdquo;: &amp;ldquo;2&amp;rdquo;,
        &amp;ldquo;name&amp;rdquo;: &amp;ldquo;c&amp;rdquo;
    },
    {
        &amp;ldquo;id&amp;rdquo;: &amp;ldquo;3&amp;rdquo;,
        &amp;ldquo;name&amp;rdquo;: &amp;ldquo;d&amp;rdquo;
    }
]
我们在界面绑定的时候仍然使用source，而在操作的时候使用dest。因为，绑定的时候，不必去经过深层检测，而操作的时候，需要有父子关系来使得操作便利。&lt;/p&gt;

&lt;p&gt;比如说，我们要做一个树状拓扑图，或者是MindMap这类产品，如果不作这样的考虑，很可能会直接把界面结构绑定到树状数据上，这时候效率相对会比较低些。&lt;/p&gt;

&lt;p&gt;但我们也可以作这种优化：&lt;/p&gt;

&lt;p&gt;同时保存扁平化的原始数据，也生成树状数据
把展示结构绑定到扁平化的数据上
每当结构变更的时候，在树状数据上更新，并且在数据模型内部计算出界面坐标
展示结构的扁平数据因为跟树状数据是相同引用，也被更新了，也就引发界面刷新
这时候，界面是单层刷新，无需跟踪层级数据，效率可以提高不少，尤其在层次较深的时候
6. 小结&lt;/p&gt;

&lt;p&gt;MVVM存在的意义就是尽可能提高开发效率，只有很极端情况下值得去优化性能。如果你的场景中出现非常多的性能问题，很可能是不适合用这类框架的业务形态。&lt;/p&gt;

&lt;p&gt;总结一下我们的几种优化方式，他们的机制分别是：&lt;/p&gt;

&lt;p&gt;减少监控项
加快变更检测速度
主动设置索引
缩小渲染的数据量
数据的扁平化
可以看到，我们所有的优化都是在数据层面，不必刻意去优化界面。如果你用了一个MVVM框架，却为它作了各种各样相当多的优化，那还不如不要用它，全手工写。&lt;/p&gt;

&lt;p&gt;针对其他MVVM框架，也大致可以用类似的几种方式，只是部分细节有差异，可以触类旁通。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>angular作用域与事件</title>
      <link>https://satisfied1.github.io/post/angular%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>Thu, 08 Dec 2016 11:09:36 +0800</pubDate>
      
      <guid>https://satisfied1.github.io/post/angular%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BA%8B%E4%BB%B6/</guid>
      <description>&lt;p&gt;作用域与事件&lt;/p&gt;

&lt;p&gt;学习Angular，首先要理解其作用域机制。&lt;/p&gt;

&lt;p&gt;Angular应用是分层的，主要有三个层面：视图，模型，视图模型。其中，视图很好理解，就是直接可见的界面，模型就是数据，那么视图模型是什么呢？是一种把数据包装给视图调用的东西。&lt;/p&gt;

&lt;p&gt;所谓作用域，也就是视图模型中的一个概念。&lt;/p&gt;

&lt;p&gt;根作用域&lt;/p&gt;

&lt;p&gt;在第一章中，有这么一个很简单的数据绑定例子：&lt;/p&gt;

&lt;p&gt;&lt;input ng-model=&#34;rootA&#34;/&gt;
&lt;div&gt;{{rootA}}&lt;/div&gt;
当时我们解释过，这个例子能够运行的的原因是，它的rootA变量被创建在根作用域上。每个Angular应用默认有一个根作用域，也就是说，如果用户未指定自己的控制器，变量就是直接挂在这个层级上的。&lt;/p&gt;

&lt;p&gt;作用域在一个Angular应用中是以树的形状体现的，根作用域位于最顶层，从它往下挂着各级作用域。每一级作用域上面挂着变量和方法，供所属的视图调用。&lt;/p&gt;

&lt;p&gt;如果想要在代码中显式使用根作用域，可以注入$rootScope。&lt;/p&gt;

&lt;p&gt;怎么证实刚才的例子中，$rootScope确实存在，而且变量真的在它上面呢？我们来写个代码：&lt;/p&gt;

&lt;p&gt;function RootService($rootScope) {
    $rootScope.$watch(&amp;ldquo;rootA&amp;rdquo;, function(newVal) {
        alert(newVal);
    });
}
这时候我们可以看到，这段代码并未跟界面产生任何关系，但里面的监控表达式确实生效了，也就是说，观测到了根作用域上rootA的变更，说明有人给它赋值了。&lt;/p&gt;

&lt;p&gt;作用域的继承关系&lt;/p&gt;

&lt;p&gt;在开发过程中，我们可能会出现控制器的嵌套，看下面这段代码：&lt;/p&gt;

&lt;div ng-controller=&#34;OuterCtrl&#34;&gt;
    &lt;span&gt;{{a}}&lt;/span&gt;
    &lt;div ng-controller=&#34;InnerCtrl&#34;&gt;
        &lt;span&gt;{{a}}&lt;/span&gt;
    &lt;/div&gt;
&lt;/div&gt;
function OuterCtrl($scope) {
    $scope.a = 1;
}

function InnerCtrl($scope) {
}
注意结果，我们可以看到界面显示了两个1，而我们只在OuterCtrl的作用域里定义了a变量，但界面给我们的结果是，两个a都有值。这里内层的a值显然来自外层，因为当我们对界面作出这样的调整之后，就只有一个了：

&lt;div ng-controller=&#34;OuterCtrl&#34;&gt;
    &lt;span&gt;{{a}}&lt;/span&gt;
&lt;/div&gt;

&lt;p&gt;&lt;div ng-controller=&#34;InnerCtrl&#34;&gt;
    &lt;span&gt;{{a}}&lt;/span&gt;
&lt;/div&gt;
这是为什么呢？在Angular中，如果两个控制器所对应的视图存在上下级关系，它们的作用域就自动产生继承关系。什么意思呢？&lt;/p&gt;

&lt;p&gt;先考虑在纯JavaScript代码中，两个构造函数各自有一个实例：&lt;/p&gt;

&lt;p&gt;function Outer() {
    this.a = 1;
}&lt;/p&gt;

&lt;p&gt;function Inner() {
}&lt;/p&gt;

&lt;p&gt;var outer = new Outer();
var inner = new Inner();
在这里面添加什么代码，能够让inner.a == 1呢？&lt;/p&gt;

&lt;p&gt;熟悉JavaScript原型的我们，当然毫不犹豫就加了一句：Inner.prototype = outer;&lt;/p&gt;

&lt;p&gt;function Outer() {
    this.a = 1;
}&lt;/p&gt;

&lt;p&gt;function Inner() {
}&lt;/p&gt;

&lt;p&gt;var outer = new Outer();
Inner.prototype = outer;
var inner = new Inner();
于是就得到想要的结果了。&lt;/p&gt;

&lt;p&gt;再回到我们的例子里，Angular的实现机制其实也就是把这两个控制器中的$scope作了关联，外层的作用域实例成为了内层作用域的原型。&lt;/p&gt;

&lt;p&gt;以此类推，整个Angular应用的作用域，都存在自顶向下的继承关系，最顶层的是$rootScope，然后一级一级，沿着不同的控制器往下，形成了一棵作用域的树，这也就像封建社会：天子高高在上，分茅裂土，公侯伯子男，一级一级往下，层层从属。&lt;/p&gt;

&lt;p&gt;简单变量的取值与赋值&lt;/p&gt;

&lt;p&gt;既然作用域是通过原型来继承的，自然也就可以推论出一些特征来。比如说这段代码，点击按钮的结果是什么？&lt;/p&gt;

&lt;p&gt;&lt;div ng-controller=&#34;OuterCtrl&#34;&gt;
    &lt;span&gt;{{a}}&lt;/span&gt;
    &lt;div ng-controller=&#34;InnerCtrl&#34;&gt;
        &lt;span&gt;{{a}}&lt;/span&gt;
        &lt;button ng-click=&#34;a=a+1&#34;&gt;a++&lt;/button&gt;
    &lt;/div&gt;
&lt;/div&gt;
function OuterCtrl($scope) {
    $scope.a = 1;
}&lt;/p&gt;

&lt;p&gt;function InnerCtrl($scope) {
}
点了按钮之后，两个a不一致了，里面的变了，外面的没变，这是为什么？原先两层不是共用一个a吗，怎么会出现两个不同的值？看这句就能明白了，相当于我们之前那个例子里，这样赋值了：&lt;/p&gt;

&lt;p&gt;function Outer() {
    this.a = 1;
}&lt;/p&gt;

&lt;p&gt;function Inner() {
}&lt;/p&gt;

&lt;p&gt;var outer = new Outer();
Inner.prototype = outer;
var inner = new Inner();&lt;/p&gt;

&lt;p&gt;inner.a = inner.a + 1;
最后这句，很有意思，它有两个过程，取值的时候，因为inner自身上面没有，所以沿着原型往上取到了1，然后自增了之后，赋值给自己，这个赋值的时候就不同了，敬爱的林副主席教导我们：有a就赋值，没有a，创造一个a也要赋值。&lt;/p&gt;

&lt;p&gt;所以这么一来，inner上面就被赋值了一个新的a，outer里面的仍然保持原样，这也就导致了刚才看到的结果。&lt;/p&gt;

&lt;p&gt;初学者在这个问题上很容易犯错，如果不能随时很明确地认识到这些变量的差异，很容易写出有问题的程序。既然这样，我们可以用一些别的方式来减少变量的歧义。&lt;/p&gt;

&lt;p&gt;对象在上下级作用域之间的共享&lt;/p&gt;

&lt;p&gt;比如说，我们就是想上下级共享变量，不创建新的，该怎么办呢？&lt;/p&gt;

&lt;p&gt;考虑下面这个例子：&lt;/p&gt;

&lt;p&gt;function Outer() {
    this.data = {
        a: 1
    };
}&lt;/p&gt;

&lt;p&gt;function Inner() {
}&lt;/p&gt;

&lt;p&gt;var outer = new Outer();
Inner.prototype = outer;&lt;/p&gt;

&lt;p&gt;var inner = new Inner();&lt;/p&gt;

&lt;p&gt;console.log(outer.data.a);
console.log(inner.data.a);&lt;/p&gt;

&lt;p&gt;// 注意，这个时候会怎样？
inner.data.a += 1;&lt;/p&gt;

&lt;p&gt;console.log(outer.data.a);
console.log(inner.data.a);
这次的结果就跟上次不同了，原因是什么呢？因为两者的data是同一个引用，对这个对象上面的属性修改，是可以反映到两级对象上的。我们通过引入一个data对象的方式，继续使用了原先的变量。把这个代码移植到AngularJS里，就变成了下面这样：&lt;/p&gt;

&lt;p&gt;&lt;div ng-controller=&#34;OuterCtrl&#34;&gt;
    &lt;span&gt;{{data.a}}&lt;/span&gt;
    &lt;div ng-controller=&#34;InnerCtrl&#34;&gt;
        &lt;span&gt;{{data.a}}&lt;/span&gt;
        &lt;button ng-click=&#34;data.a=data.a+1&#34;&gt;increase a&lt;/button&gt;
    &lt;/div&gt;
&lt;/div&gt;
function OuterCtrl($scope) {
    $scope.data = {
        a: 1
    };
}&lt;/p&gt;

&lt;p&gt;function InnerCtrl($scope) {
}
从这个例子我们就发现了，如果想要避免变量歧义，显式指定所要使用的变量会是比较好的方式，那么如果我们确实就是要在上下级分别存在相同的变量该怎么办呢，比如说下级的点击，想要给上级的a增加1，我们可以使用$parent来指定上级作用域。&lt;/p&gt;

&lt;p&gt;&lt;div ng-controller=&#34;OuterCtrl&#34;&gt;
    &lt;span&gt;{{a}}&lt;/span&gt;
    &lt;div ng-controller=&#34;InnerCtrl&#34;&gt;
        &lt;span&gt;{{a}}&lt;/span&gt;
        &lt;button ng-click=&#34;$parent.a=a+1&#34;&gt;increase a&lt;/button&gt;
    &lt;/div&gt;
&lt;/div&gt;
function OuterCtrl($scope) {
    $scope.a = 1;
}&lt;/p&gt;

&lt;p&gt;function InnerCtrl($scope) {
}
控制器实例别名&lt;/p&gt;

&lt;p&gt;从Angular 1.2开始，引入了控制器实例的别名机制。在之前，可能都需要向控制器注入$scope，然后，控制器里面定义可绑定属性和方法都是这样：&lt;/p&gt;

&lt;p&gt;function CtrlA($scope) {
    $scope.a = 1;
    $scope.foo = function() {
    };
}
&lt;div ng-controller=&#34;CtrlA&#34;&gt;
    &lt;div&gt;{{a}}&lt;/div&gt;
    &lt;button ng-click=&#34;foo()&#34;&gt;click me&lt;/button&gt;
&lt;/div&gt;
其实$scope的注入是一个比较冗余的概念，没有必要把这种概念过分暴露给用户。在应用中出现的作用域，有的是充当视图模型，而有些则是处于隔离数据的需要，前者如ng-controller，后者如ng-repeat。在最近版本的AngularJS中，已经可以不显式注入$scope了，语法是这样：&lt;/p&gt;

&lt;p&gt;function CtrlB() {
    this.a = 1;
    this.foo = function() {
    };
}
这里面，就完全没有$scope的身影了，那这个控制器怎么使用呢？&lt;/p&gt;

&lt;p&gt;&lt;div ng-controller=&#34;CtrlB as instanceB&#34;&gt;
    &lt;div&gt;{{instanceB.a}}&lt;/div&gt;
    &lt;button ng-click=&#34;instanceB.foo()&#34;&gt;click me&lt;/button&gt;
&lt;/div&gt;
注意我们在引入控制器的时候，加了一个as语法，给CtrlB的实例取了一个别名叫做instanceB，这样，它下属的各级视图都可以显式使用这个名称来调用其属性和方法，不易引起歧义。&lt;/p&gt;

&lt;p&gt;在开发过程中，为了避免模板中的变量歧义，应当尽可能使用命名限定，比如a.b，出现歧义的可能性就比单独的b要少得多。&lt;/p&gt;

&lt;p&gt;不请自来的新作用域&lt;/p&gt;

&lt;p&gt;在一个应用中，最常见的会创建作用域的指令是ng-controller，这个很好理解，因为它会实例化一个新的控制器，往里面注入一个$scope，也就是一个新的作用域，所以一般人都会很自然地理解这里面的作用域隔离关系。但是对于另外一些情况，就有些困惑了，比如说，ng-repeat，怎么理解这个东西也会创建新作用域呢？&lt;/p&gt;

&lt;p&gt;还是看之前的例子：&lt;/p&gt;

&lt;p&gt;$scope.arr = [1, 2, 3];
&lt;ul&gt;
    &lt;li ng-repeat=&#34;item in arr track by $index&#34;&gt;{{item}}&lt;/li&gt;
&lt;/ul&gt;
在ng-repeat的表达式里，有一个item，我们来思考一下，这个item是个什么情况。在这里，数组中有三个元素，在循环的时候，这三个元素都叫做item，这时候就有个问题，如何区分每个不同的item，可能我们这个例子还不够直接，那改一下：&lt;/p&gt;

&lt;p&gt;&lt;div&gt;outer: {{sum1}}&lt;/div&gt;
&lt;ul&gt;
    &lt;li ng-repeat=&#34;item in arr track by $index&#34;&gt;
        {{item}}
        &lt;button ng-click=&#34;sum1=sum1+item&#34;&gt;increase&lt;/button&gt;
        &lt;div&gt;inner: {{sum1}}&lt;/div&gt;
    &lt;/li&gt;
&lt;/ul&gt;
这个例子运行一下，我们会发现每个item都会独立改变，说明它们确实是区分开了的。事实上，Angular在这里为ng-repeat的每个子项都创建了单独的作用域，所以，每个item都存在于自己的作用域里，互不影响。有时候，我们是需要在循环内部访问外层变量的，回忆一下，在本章的前面部分中，我们举例说，如果两个控制器，它们的视图有包含关系，内层控制器的作用域可以通过$parent来访问外层控制器作用域上的变量，那么，在这种循环里，是不是也可以如此呢？&lt;/p&gt;

&lt;p&gt;看这个例子：&lt;/p&gt;

&lt;p&gt;&lt;div&gt;outer: {{sum2}}&lt;/div&gt;
&lt;ul&gt;
    &lt;li ng-repeat=&#34;item in arr track by $index&#34;&gt;
        {{item}}
        &lt;button ng-click=&#34;$parent.sum2=sum2+item&#34;&gt;increase&lt;/button&gt;
        &lt;div&gt;inner: {{sum2}}&lt;/div&gt;
    &lt;/li&gt;
&lt;/ul&gt;
果然是可以的。很多时候，人们会把$parent误认为是上下两级控制器之间的访问通道，但从这个例子我们可以看到，并非如此，只是两级作用域而已，作用域跟控制器还是不同的，刚才的循环可以说是有两级作用域，但都处于同一个控制器之中。&lt;/p&gt;

&lt;p&gt;刚才我们已经提到了ng-controller和ng-repeat这两个常用的内置指令，两者都会创建新的作用域，除此之外，还有一些其他指令也会创建新的作用域，很多初学者在使用过程中很容易产生困扰。&lt;/p&gt;

&lt;p&gt;第一章我们提到用ng-show和ng-hide来控制某个界面块的整体展示和隐藏，但同样的功能其实也可以用ng-if来实现。那么这两者的差异是什么呢，所谓show和hide，大家很好理解，就是某个东西原先有，只是控制是否显式，而if的含义是，如果满足条件，就创建这块DOM，否则不创建。所以，ng-if所控制的界面块，只有条件为真的时候才会存在于DOM树中。&lt;/p&gt;

&lt;p&gt;除此之外，两者还有个差异，ng-show和ng-hide是不自带作用域的，而ng-if则自己创建了一级作用域。在用的时候，两者就是有差别的，比如说内部元素访问外层定义的变量，就需要使用类似ng-repeat那样的$parent语法了。&lt;/p&gt;

&lt;p&gt;相似的类型还有ng-switch，ng-include等等，规律可以总结，也就是那些会动态创建一块界面的东西，都是自带一级作用域。&lt;/p&gt;

&lt;p&gt;“悬空”的作用域&lt;/p&gt;

&lt;p&gt;一般而言，在Angular工程中，基本是不需要手动创建作用域的，但真想创建的话，也是可以做到的。在任意一个已有的作用域上调用$new()，就能创建一个新的作用域：&lt;/p&gt;

&lt;p&gt;var newScope = scope.$new();
刚创建出来的作用域是一个“悬空”的作用域，也就是说，它跟任何界面模板都不存在绑定关系，创建它的作用域会成为它的$parent。这种作用域可以经过$compile阶段，与某视图模板进行融合。&lt;/p&gt;

&lt;p&gt;为了帮助理解，我们可以用DocumentFragment作类比，当作用域被创建的时候，就好比是创建了一个DocumentFragment，它是不在DOM树上的，只有当它被append到DOM树上，才能够被当做普通的DOM来使用。&lt;/p&gt;

&lt;p&gt;那么，悬空的作用域是不是什么用处都没有呢？也不是，尽管它未与视图关联，但是它的一些方法仍然可以用。&lt;/p&gt;

&lt;p&gt;我们在第一章里提到了$watch，这就是定义在作用域原型上的。如果我们想要监控一个数据的变化，但这个数据并非绑定到界面上的，比如下面这样，怎么办？&lt;/p&gt;

&lt;p&gt;function IsolateCtrl($scope) {
    var child = {
        a: 1
    };&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;child.a++;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
注意这个child，它并未绑定到$scope上，如果我们想要在a变化的时候做某些事情，是没有办法做的，因为直到最近的某些浏览器中，才实现了Object.observe这样的对象变更观测方法，之前某些浏览器中要做这些，会比较麻烦。&lt;/p&gt;

&lt;p&gt;但是我们的$watch和$eval之类的方法，其实都是实现在作用域对象上的，也就是说，任何一个作用域，即使没有与界面产生关联，也是能够使用这些方法的。&lt;/p&gt;

&lt;p&gt;function IsolateCtrl($scope) {
    var child = $scope.$new();
    child.a = 1;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;child.$watch(&amp;quot;a&amp;quot;, function(newValue) {
    alert(newValue);
});

$scope.change = function() {
    child.a++;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
这时候child里面a的变更就可以被观测到，并且，这个child只有本作用域可以访问到，相当于是一个增强版的数据模型。如果我们要做一个小型流程引擎之类的东西，作用域对象上提供的这些方法会很有用。&lt;/p&gt;

&lt;p&gt;作用域上的事件&lt;/p&gt;

&lt;p&gt;我们刚才提到使用$parent来处理上下级的通讯，但其实这不是一种好的方式，尤其是在不同控制器之间，这会增加它们的耦合，对组件复用很不利。那怎样才能更好地解耦呢？我们可以使用事件。&lt;/p&gt;

&lt;p&gt;提到事件，可能很多人想到的都是DOM事件，其实DOM事件只存在于上层，而且没有业务含义，如果我们想要传递一个明确的业务消息，就需要使用业务事件。这种所谓的业务事件，其实就是一种消息的传递。&lt;/p&gt;

&lt;p&gt;假设有如图所示的应用：&lt;/p&gt;

&lt;p&gt;事件的传递&lt;/p&gt;

&lt;p&gt;这张图中有一个应用，下面存在两个视图块A和B，它们分别又有两个子视图。这时候，如果子视图A1想要发出一个业务事件，使得B1和B2能够得到通知，过程就会是：&lt;/p&gt;

&lt;p&gt;沿着父作用域一路往上到达双方共同的祖先作用域
从祖先作用域一级一级往下进行广播，直到到达需要的地方
刚才的图形体现了界面的包含关系，如果把这个图再立体化，就会是下面这样：&lt;/p&gt;

&lt;p&gt;事件的传递&lt;/p&gt;

&lt;p&gt;对于这种事件的传播方式，可以有个类似的比喻：&lt;/p&gt;

&lt;p&gt;比如说，某军队中，1营1连1排长想要给1营2连下属的三个排发个警戒通知，他的通知方向是一级一级向上汇报，直到双方共同的上级，也就是1营指挥人员这里，然后再沿着二连这个路线向下去通知。&lt;/p&gt;

&lt;p&gt;从作用域往上发送事件，使用scope.$emit
$scope.$emit(&amp;ldquo;someEvent&amp;rdquo;, {});
从作用域往下发送事件，使用scope.$broadcast
$scope.$broadcast(&amp;ldquo;someEvent&amp;rdquo;, {});
这两个方法的第二个参数是要随事件带出的数据。&lt;/p&gt;

&lt;p&gt;注意，这两种方式传播事件，事件的发送方自己也会收到一份。&lt;/p&gt;

&lt;p&gt;使用事件的主要作用是消除模块间的耦合，发送方是不需要知道接收方的状况的，接收方也不需要知道发送方的状况，双方只需要传送必要的业务数据即可。&lt;/p&gt;

&lt;p&gt;事件的接收与阻止&lt;/p&gt;

&lt;p&gt;无论是$emit还是$broadcast发送的事件，都可以被接收，接收这两种事件的方式是一样的：&lt;/p&gt;

&lt;p&gt;$scope.$on(&amp;ldquo;someEvent&amp;rdquo;, function(e) {
    // 这里从e上可以取到发送过来的数据
});
注意，事件被接收了，并不代表它就中止了，它仍然会沿着原来的方向继续传播，也就是：&lt;/p&gt;

&lt;p&gt;$emit的事件将继续向上传播
$broadcast的事件将继续向下传播
有时候，我们希望某一级收到事件之后，就让它停下来，不再传播，可以把事件中止。这时候，两种事件的区别就体现出来了，只有$emit发出的事件是可以被中止的，$broadcast发出的不可以。&lt;/p&gt;

&lt;p&gt;如果想要阻止$emit事件的继续传播，可以调用事件对象的stopPropagation()方法。&lt;/p&gt;

&lt;p&gt;$scope.$on(&amp;ldquo;someEvent&amp;rdquo;, function(e) {
    e.stopPropagation();
});
但是，想要阻止$broadcast事件的传播，就麻烦了，我们只能通过变通的方式：&lt;/p&gt;

&lt;p&gt;首先，调用事件对象的preventDefault()方法，然后，在收取这个事件对象的时候，判断它的defaultPrevented属性，如果为true，就忽略此事件。这个过程比较麻烦，其实我们一般是不需要管的，只要不监听对应的事件就可以了。在实际使用过程中，也应当尽量少使用事件的广播，尤其是从较高的层级进行广播。&lt;/p&gt;

&lt;p&gt;上级作用域&lt;/p&gt;

&lt;p&gt;$scope.$on(&amp;ldquo;someEvent&amp;rdquo;, function(e) {
    e.preventDefault();
});
下级作用域&lt;/p&gt;

&lt;p&gt;$scope.$on(&amp;ldquo;someEvent&amp;rdquo;, function(e) {
    if (e.defaultPrevented) {
        return;
    }
});
事件总线&lt;/p&gt;

&lt;p&gt;在Angular中，不同层级作用域之间的数据通信有多种方式，可以通过原型继承的一些特征，也可以收发事件，还可以使用服务来构造单例对象进行通信。&lt;/p&gt;

&lt;p&gt;前面提到的这个军队的例子，有些时候沟通效率比较低，特别是层级多的时候。想象一下，刚才这个只有三层，如果更复杂，一个排长的消息都一定要报告到军长那边再下发到其他基层主官，必定贻误军情，更何况有很多下级根本不需要知道这个消息。
那怎么办呢，难道是直接打电话沟通吗？这个效率高是高，就是容易乱，这也就相当于界面块之间的直接通过id调用。&lt;/p&gt;

&lt;p&gt;Angular的作用域树类似于传统的组织架构树，一个大型企业，一般都会有若干层级，近年来有很多管理的方法论，比如说组织架构的扁平化。&lt;/p&gt;

&lt;p&gt;我们能不能这样：搞一个专门负责通讯的机构，大家的消息都发给它，然后由它发给相关人员，其他人员在理念上都是平级关系。&lt;/p&gt;

&lt;p&gt;这就是一个很典型的订阅发布模式，接收方在这里订阅消息，发布方在这里发布消息。这个过程可以用这样的图形来表示：&lt;/p&gt;

&lt;p&gt;应用内的事件总线&lt;/p&gt;

&lt;p&gt;代码写起来也很简单，把它做成一个公共模块，就可以被各种业务方调用了：&lt;/p&gt;

&lt;p&gt;app.factory(&amp;ldquo;EventBus&amp;rdquo;, function() {
    var eventMap = {};&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var EventBus = {
    on : function(eventType, handler) {
        //multiple event listener
        if (!eventMap[eventType]) {
            eventMap[eventType] = [];
        }
        eventMap[eventType].push(handler);
    },

    off : function(eventType, handler) {
        for (var i = 0; i &amp;lt; eventMap[eventType].length; i++) {
            if (eventMap[eventType][i] === handler) {
                eventMap[eventType].splice(i, 1);
                break;
            }
        }
    },

    fire : function(event) {
        var eventType = event.type;
        if (eventMap &amp;amp;&amp;amp; eventMap[eventType]) {
            for (var i = 0; i &amp;lt; eventMap[eventType].length; i++) {
                eventMap[eventType][i](event);
            }
        }
    }
};
return EventBus;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;});
事件订阅代码：&lt;/p&gt;

&lt;p&gt;EventBus.on(&amp;ldquo;someEvent&amp;rdquo;, function(event) {
    // 这里处理事件
    var c = event.data.a + event.data.b;
});
事件发布代码：&lt;/p&gt;

&lt;p&gt;EventBus.fire({
    type: &amp;ldquo;someEvent&amp;rdquo;,
    data: {
        aaa: 1,
        bbb: 2
    }
});
注意，如果在复杂的应用中使用事件总线，需要慎重规划事件名，推荐使用业务路径，比如：&amp;rdquo;portal.menu.selectedMenuChange&amp;rdquo;，以避免事件冲突。&lt;/p&gt;

&lt;p&gt;小结&lt;/p&gt;

&lt;p&gt;在本章，我们学习了作用域相关的知识，以及它们之间传递数据的方式。作用域在整个Angular应用中形成了一棵树，以$rootScope为根部，开枝散叶。这棵树独立于DOM而存在，又与DOM相关联。事件在整个树上传播，如蜂飞蝶舞。&lt;/p&gt;

&lt;p&gt;总体来说，使用AngularJS对JavaScript的基本功是有一定要求的，因为这里面大部分实现都依赖于纯JavaScript语法，比如原型继承的使用。如果对这一块有充分的认识，理解Angular的作用域就会比较容易。&lt;/p&gt;

&lt;p&gt;一个大型单页应用，需要对部件的整合方式和通信机制作良好的规划，为它们建立良好的秩序，这对于确保整个应用的稳定性是非常必要的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>angular数据绑定与监控</title>
      <link>https://satisfied1.github.io/post/angular%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E4%B8%8E%E7%9B%91%E6%8E%A7/</link>
      <pubDate>Thu, 08 Dec 2016 11:08:52 +0800</pubDate>
      
      <guid>https://satisfied1.github.io/post/angular%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E4%B8%8E%E7%9B%91%E6%8E%A7/</guid>
      <description>&lt;p&gt;数据绑定与监控&lt;/p&gt;

&lt;p&gt;在业务开发的过程中，我们可能会大量使用DOM操作，这个过程很繁琐，但是有了AngularJS，基本上就可以解脱了，做到这一点的关键是数据绑定。那什么是数据绑定，怎样绑定呢？本节将从多种角度，选取业务开发过程中的各种场景来举例说明。&lt;/p&gt;

&lt;p&gt;基于单一模型的界面同步&lt;/p&gt;

&lt;p&gt;有时候，我们会有这样的需求，界面上有个输入框，然后有另外一个地方，要把这个文本原样显示出来，如果没有数据绑定，这个代码可能很麻烦了，比如说，我们要监听输入框的各种事件，键盘按键、复制粘贴等等，然后再把取得的值写入对应位置。但是如果有数据绑定，这个事情就非常简单。&lt;/p&gt;

&lt;p&gt;&lt;input type=&#34;text&#34; ng-model=&#34;a&#34;/&gt;
&lt;div&gt;{{a}}&lt;/div&gt;
这么小小一段代码，就实现了我们想要的功能，是不是很可爱？这中间的关键是什么呢，就是变量a，在这里，变量a充当了数据模型的角色，输入框的数据变更会同步到模型上，然后再分发给绑定到这个模型的其他UI元素。&lt;/p&gt;

&lt;p&gt;注意，任意绑定到数据模型的输入元素，它的数据变更都会导致模型变更，比如说，我们有另外一个需求，两个输入框，我们想要在任意一个中输入的时候，另外一个的值始终跟它保持同步。如果用传统的方式，需要在两个输入框上都添加事件，但是有了数据绑定之后，这一切都很简单：&lt;/p&gt;

&lt;p&gt;&lt;input type=&#34;text&#34; ng-model=&#34;b&#34;/&gt;
&lt;input type=&#34;text&#34; ng-model=&#34;b&#34;/&gt;
这样的代码就可以了，核心要素还是这个数据模型b。&lt;/p&gt;

&lt;p&gt;到目前为止的两个例子都很简单，但可能有人有问题要问，因为我们什么js都没有写，这个a跟b是哪里来的，为什么就能起作用呢？对于这个问题，我来作个类比。&lt;/p&gt;

&lt;p&gt;比如大家写js，都知道变量可以不声明就使用：&lt;/p&gt;

&lt;p&gt;a = 1;
这时候a被赋值到哪里了呢，到了全局的window对象上，也就是说其实相当于：&lt;/p&gt;

&lt;p&gt;window.a = 1;
在AngularJS里，变量和表达式都附着在一种叫做作用域（scope）的东西上，可以自己声明新的作用域，也可以不声明。每个Angular应用默认会有一个根作用域（$rootScope），凡是没有预先声明的东西，都会被创建到它上面去。&lt;/p&gt;

&lt;p&gt;作用域的相关概念，我们会在下一章里面讲述。在这里，我们只需要知道，如果在界面中绑定了未定义的某变量，当它被赋值的时候，就会自动创建到对应的作用域上去。&lt;/p&gt;

&lt;p&gt;前面我们在例子中提到的{{}}这种符号，称为插值表达式，这里面的内容将会被动态解析，也可以不使用这种方式来进行绑定，Angular另有一个ng-bind指令用于做这种事情：&lt;/p&gt;

&lt;p&gt;&lt;input ng-model=&#34;a&#34;/&gt;
&lt;div&gt;{{a}}&lt;/div&gt;
&lt;div ng-bind=&#34;a&#34;&gt;&lt;/div&gt;
对模型的二次计算&lt;/p&gt;

&lt;p&gt;嗯，有时候，实际情况没有这么简单，比如说，我们可能会需要对数据作一点处理，比如，在每个表示价格的数字后面添加一个单位：&lt;/p&gt;

&lt;p&gt;&lt;input type=&#34;number&#34; ng-model=&#34;price&#34;/&gt;
&lt;span&gt;{{price + &amp;ldquo;（元）&amp;rdquo;}}&lt;/span&gt;
当然我们这个例子并不好，因为，其实你可以把无关的数据都放在绑定表达式的外面，就像这样：&lt;/p&gt;

&lt;p&gt;&lt;input type=&#34;number&#34; ng-model=&#34;price&#34;/&gt;
&lt;span&gt;{{price}}（元）&lt;/span&gt;
那么，考虑个稍微复杂一些的。我们经常会遇到，在界面上展示性别，但是数据库里面存的是0或者1，那么，总要对它作个转换。有些比较老土的做法是这样，在模型上添加额外的字段给显示用：&lt;/p&gt;

&lt;p&gt;这是原始数据：&lt;/p&gt;

&lt;p&gt;var tom = {
    name: &amp;ldquo;Tom&amp;rdquo;,
    gender: 1
};
被他转换之后，成了这样：&lt;/p&gt;

&lt;p&gt;var tom = {
    name: &amp;ldquo;Tom&amp;rdquo;,
    gender: 1,
    genderText: &amp;ldquo;男&amp;rdquo;
};
转换函数内容如下：&lt;/p&gt;

&lt;p&gt;if (person.gender == 0)
    person.genderText = &amp;ldquo;女&amp;rdquo;;&lt;/p&gt;

&lt;p&gt;if (person.gender == 1)
    person.genderText = &amp;ldquo;男&amp;rdquo;;
这样的做法虽然能够达到效果，但破坏了模型的结构，我们可以做些改变：&lt;/p&gt;

&lt;p&gt;&lt;div&gt;{{formatGender(tom.gender)}}&lt;/div&gt;
$scope.formatGender = function(gender) {
    if (gender == 0)
        return &amp;ldquo;女&amp;rdquo;;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (gender == 1)
    return &amp;quot;男&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;};
这样我们就达到了目的。这个例子让我们发现，原来，在绑定表达式里面，是可以使用函数的。像我们这里的格式化函数，其实作用只存在于视图层，所以不会影响到真实数据模型。&lt;/p&gt;

&lt;p&gt;注意：这里有两个注意点。&lt;/p&gt;

&lt;p&gt;第一，在绑定表达式里面，只能使用自定义函数，不能使用原生函数。举个例子：&lt;/p&gt;

&lt;p&gt;&lt;div&gt;{{Math.abs(-1)}}&lt;/div&gt;
这句就是有问题的，因为Angular的插值表达式机制决定了它不能使用这样的函数，它是直接用自己的解释器去解析这个字符串的，如果确实需要调用原生函数，可以用一个自定义函数作包装，在自定义函数里面可以随意使用各种原生对象，就像这样：&lt;/p&gt;

&lt;p&gt;&lt;div&gt;{{abs(-1)}}&lt;/div&gt;
$scope.abs = function(number) {
    return Math.abs(number);&lt;br /&gt;
};
第二，刚才我们这个例子只是为了说明可以这么用，但不表示这是最佳方案。Angular为这类需求提供了一种叫做filter的方案，可以在插值表达式中使用管道操作符来格式化数据，这个我们后面再细看。&lt;/p&gt;

&lt;p&gt;数组与对象结构的绑定&lt;/p&gt;

&lt;p&gt;有时候，我们的数据并不总是这么简单，比如说，有可能会需要把一个数组的数据展示出来，这种情况下可以使用Angular的ng-repeat指令来处理，这个东西相当于一个循环，比如我们来看这段例子：&lt;/p&gt;

&lt;p&gt;$scope.arr1 = [1, 2, 3];&lt;/p&gt;

&lt;p&gt;$scope.add = function() {
    $scope.arr1.push($scope.arr1.length + 1);
};
&lt;button ng-click=&#34;add()&#34;&gt;Add Item&lt;/button&gt;
&lt;ul&gt;
    &lt;li ng-repeat=&#34;item in arr1&#34;&gt;{{item}}&lt;/li&gt;
&lt;/ul&gt;
这样就可以把数组的内容展示到界面上了。数组中的数据产生变化时，也能够实时更新到界面上来。&lt;/p&gt;

&lt;p&gt;有时候，我们会遇到数组里有重复元素的情况，这时候，ng-repeat代码不能起作用，原因是Angular默认需要在数组中使用唯一索引，那假如我们的数据确实如此，怎么办呢？可以指定它使用序号作索引，就像这样：&lt;/p&gt;

&lt;p&gt;$scope.arr2 = [1, 1, 3];
&lt;ul&gt;
    &lt;li ng-repeat=&#34;item in arr2 track by $index&#34;&gt;{{item}}&lt;/li&gt;
&lt;/ul&gt;
也可以把多维数组用多层循环的方式迭代出来：&lt;/p&gt;

&lt;p&gt;$scope.arr3 = [
    [11, 12, 13],
    [21, 22, 23],
    [31, 32, 33]
];
&lt;ul&gt;
    &lt;li ng-repeat=&#34;childArr in arr3 track by $index&#34;&gt;
        {{$index}}
        &lt;ul&gt;
            &lt;li ng-repeat=&#34;item in childArr track by $index&#34;&gt;{{item}}&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/li&gt;
&lt;/ul&gt;
如果是数组中的元素是对象结构，也不难，我们用个表格来展示这个数组：&lt;/p&gt;

&lt;p&gt;$scope.arr4 = [{
    name: &amp;ldquo;Tom&amp;rdquo;,
    age: 5
}, {
    name: &amp;ldquo;Jerry&amp;rdquo;,
    age: 2
}];
&lt;table class=&#34;table table-bordered&#34;&gt;
    &lt;thead&gt;
    &lt;tr&gt;
        &lt;th&gt;Name&lt;/th&gt;
        &lt;th&gt;Age&lt;/th&gt;
    &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
    &lt;tr ng-repeat=&#34;child in arr4&#34;&gt;
        &lt;td&gt;{{child.name}}&lt;/td&gt;
        &lt;td&gt;{{child.age}}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
有时候我们想遍历对象的属性，也可以使用ng-repeat指令：&lt;/p&gt;

&lt;p&gt;$scope.obj = {
    a: 1,
    b: 2,
    c: 3
};
&lt;ul&gt;
    &lt;li ng-repeat=&#34;(key, value) in obj&#34;&gt;{{key}}: {{value}}&lt;/li&gt;
&lt;/ul&gt;
注意，在ng-repeat表达式里，我们使用了一个(key, value)来描述键值关系，如果只想要值，也可以不用这么写，直接按照数组的写法即可。对象值有重复的话，不用像数组那么麻烦需要指定$index做索引，因为它是对象的key做索引，这是不会重复的。&lt;/p&gt;

&lt;p&gt;数据监控&lt;/p&gt;

&lt;p&gt;有时候，我们不是直接把数据绑定到界面上，而是先要赋值到其他变量上，或者针对数据的变更，作出一些逻辑的处理，这个时候就需要使用监控。&lt;/p&gt;

&lt;p&gt;最基本的监控很简单：&lt;/p&gt;

&lt;p&gt;$scope.a = 1;&lt;/p&gt;

&lt;p&gt;$scope.$watch(&amp;ldquo;a&amp;rdquo;, function(newValue, oldValue) {
    alert(oldValue + &amp;ldquo; -&amp;gt; &amp;rdquo; + newValue);
});&lt;/p&gt;

&lt;p&gt;$scope.changeA = function() {
    $scope.a++;
};
对作用域上的变量添加监控之后，就可以在变更时得到通知了。如果说新赋值的变量跟原先的相同，这个监控就不会被执行。比如说刚才例子中，继续对a赋值为1，不会进入监控函数。&lt;/p&gt;

&lt;p&gt;以上这种方式可以监控到最直接的赋值，包括各种基本类型，以及复杂类型的引用赋值，比如说下面这个数组被重新赋值了，就可以被监控到：&lt;/p&gt;

&lt;p&gt;$scope.arr = [0];&lt;/p&gt;

&lt;p&gt;$scope.$watch(&amp;ldquo;arr&amp;rdquo;, function(newValue) {
    alert(&amp;ldquo;change:&amp;rdquo; + newValue.join(&amp;ldquo;,&amp;rdquo;));
});&lt;/p&gt;

&lt;p&gt;$scope.changeArr = function() {
    $scope.arr = [7, 8];
};
但这种监控方式只能处理引用相等的判断，对于一些更复杂的监控，需要更细致的处理。比如说，我们有可能需要监控一个数组，但并非监控它的整体赋值，而是监控其元素的变更：&lt;/p&gt;

&lt;p&gt;$scope.$watch(&amp;ldquo;arr&amp;rdquo;, function(newValue) {
    alert(&amp;ldquo;deep:&amp;rdquo; + newValue.join(&amp;ldquo;,&amp;rdquo;));
}, true);&lt;/p&gt;

&lt;p&gt;$scope.addItem = function() {
    $scope.arr.push($scope.arr.length);
};
注意，这里我们在$watch函数中，添加了第三个参数，这个参数用于指示对数据的深层监控，包括数组的子元素和对象的属性等等。&lt;/p&gt;

&lt;p&gt;样式的数据绑定&lt;/p&gt;

&lt;p&gt;刚才我们提到的例子，都是跟数据同步、数据展示相关，但数据绑定的功能是很强大的，其应用场景取决于我们的想象力。&lt;/p&gt;

&lt;p&gt;不知道大家有没有遇到过这样的场景，有一个数据列表，点中其中某条，这条就改变样式变成加亮，如果用传统的方式，可能要添加一些事件，然后在其中作一些处理，但使用数据绑定，能够大幅简化代码：&lt;/p&gt;

&lt;p&gt;function ListCtrl($scope) {
    $scope.items = [];&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (var i=0; i&amp;lt;10; i++) {
    $scope.items.push({
        title:i
    });
}

$scope.selectedItem = $scope.items[0];

$scope.select = function(item) {
    $scope.selectedItem = item;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
&lt;ul class=&#34;list-group&#34; ng-controller=&#34;ListCtrl&#34;&gt;
    &lt;li ng-repeat=&#34;item in items&#34; ng-class=&#34;{true:&#39;list-group-item active&#39;, false: &#39;list-group-item&#39;}[item==selectedItem]&#34; ng-click=&#34;select(item)&#34;&gt;
        {{item.title}}
    &lt;/li&gt;
&lt;/ul&gt;
在本例中，我们使用了一个循环来迭代数组中的元素，并且使用一个变量selectedItem用于标识选中项，然后关键点在于这个ng-class的表达式，它能够根据当前项是否为选中项，作出一个判断，生成对应的样式名。这是绑定的一个典型应用了，基于它，能把一些之前需要依赖于某些控件的功能用特别简单的方式做出来。&lt;/p&gt;

&lt;p&gt;除了使用ng-class，还可以使用ng-style来对样式作更细致的控制，比如：&lt;/p&gt;

&lt;p&gt;&lt;input type=&#34;number&#34; ng-model=&#34;x&#34; ng-init=&#34;x=12&#34;/&gt;
&lt;div ng-style=&#34;{&#39;font-size&#39;: x+&#39;pt&#39;}&#34;&gt;
    测试字体大小
&lt;/div&gt;
状态控制&lt;/p&gt;

&lt;p&gt;有时候，我们除了控制普通的样式，还有可能要控制某个界面元素的显示隐藏。我们用ng-class或者ng-style当然都是可以控制元素的显示隐藏的，但Angular给我们提供了一种快捷方式，那就是ng-show和ng-hide，它们是相反的，其实只要一个就可以了，提供两个是为了写表达式的方便。&lt;/p&gt;

&lt;p&gt;利用数据绑定，我们可以很容易实现原有的一些显示隐藏功能。比如说，当列表项有选中的时候，某些按钮出现，当什么都没选的时候，不出现这些按钮。&lt;/p&gt;

&lt;p&gt;主要的代码部分还是借用上面那个列表，只添加一些相关的东西：&lt;/p&gt;

&lt;p&gt;&lt;button ng-show=&#34;selectedItem&#34;&gt;有选中项的时候可以点我&lt;/button&gt;
&lt;button ng-hide=&#34;selectedItem&#34;&gt;没有选中项的时候可以点我&lt;/button&gt;
把这个代码放在刚才的列表旁边，位于同一个controller下，点击列表元素，就能看到绑定状态了。&lt;/p&gt;

&lt;p&gt;有时候，我们也想控制按钮的可点击状态，比如刚才的例子，那两个按钮直接显示隐藏，太突兀了，我们来把它们改成启用和禁用。&lt;/p&gt;

&lt;p&gt;&lt;button ng-disabled=&#34;!selectedItem&#34;&gt;有选中项的时候可以点我&lt;/button&gt;
&lt;button ng-disabled=&#34;selectedItem&#34;&gt;没有选中项的时候可以点我&lt;/button&gt;
同理，如果是输入框，可以用同样的方式，使用ng-readonly来控制其只读状态。&lt;/p&gt;

&lt;p&gt;流程控制&lt;/p&gt;

&lt;p&gt;除了使用ng-show和ng-hide来控制元素的显示隐藏，还可以使用ng-if，但这个的含义与实现机制都大为不同。所谓的show和hide，意味着DOM元素已经存在，只是控制了是否显示，而if则起到了流程控制的作用，只有符合条件的DOM元素才会被创建，否则不创建。&lt;/p&gt;

&lt;p&gt;比如下面的例子：&lt;/p&gt;

&lt;p&gt;function IfCtrl($scope) {
    $scope.condition = 1;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$scope.change = function() {
    $scope.condition = 2;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
&lt;div ng-controller=&#34;IfCtrl&#34;&gt;
    &lt;ul&gt;
        &lt;li ng-if=&#34;condition==1&#34;&gt;if 1&lt;/li&gt;
        &lt;li ng-if=&#34;condition==2&#34;&gt;if 2&lt;/li&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;li ng-show=&amp;quot;condition==1&amp;quot;&amp;gt;show 1&amp;lt;/li&amp;gt;
    &amp;lt;li ng-show=&amp;quot;condition==2&amp;quot;&amp;gt;show 2&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;

&amp;lt;button ng-click=&amp;quot;change()&amp;quot;&amp;gt;change&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/div&gt;
这个例子初始的时候，创建了三个li，其中一个被隐藏（show 2），当点击按钮，condition变成2，仍然是三个li，其中，if 1没有了，if 2创建出来了，show 1隐藏了，show 2显示了。&lt;/p&gt;

&lt;p&gt;所以，我们现在看到的是，if的节点是动态创建的。与此类似，我们还可以使用ng-switch指令：&lt;/p&gt;

&lt;p&gt;function SwitchCtrl($scope) {
    $scope.condition = &amp;ldquo;&amp;rdquo;;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$scope.a = function() {
    $scope.condition = &amp;quot;A&amp;quot;;
};

$scope.b = function() {
    $scope.condition = &amp;quot;B&amp;quot;;
};

$scope.c = function() {
    $scope.condition = &amp;quot;C&amp;quot;;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
&lt;div ng-controller=&#34;SwitchCtrl&#34;&gt;
    &lt;div ng-switch=&#34;condition&#34;&gt;
        &lt;div ng-switch-when=&#34;A&#34;&gt;A&lt;/div&gt;
        &lt;div ng-switch-when=&#34;B&#34;&gt;B&lt;/div&gt;
        &lt;div ng-switch-default&gt;default&lt;/div&gt;
    &lt;/div&gt;
    &lt;button ng-click=&#34;a()&#34;&gt;A&lt;/button&gt;
    &lt;button ng-click=&#34;b()&#34;&gt;B&lt;/button&gt;
    &lt;button ng-click=&#34;c()&#34;&gt;C&lt;/button&gt;
&lt;/div&gt;
这个例子跟if基本上是一个意思，只是语法更自然些。&lt;/p&gt;

&lt;p&gt;数据联动&lt;/p&gt;

&lt;p&gt;在做实际业务的过程中，很容易就碰到数据联动的场景，最典型的例子是省市县的三级联动。很多前端教程或者基础面试题以此为例，综合考察其中所运用到的知识点。&lt;/p&gt;

&lt;p&gt;如果是用Angular做开发，很可能这个就不成其为一个考点了，因为实现起来非常容易。&lt;/p&gt;

&lt;p&gt;我们刚才已经实现了一个单级列表，可以借用这段代码，做两个列表，第一个的数据变动，对第二个的数据产生过滤。&lt;/p&gt;

&lt;p&gt;function RegionCtrl($scope) {
    $scope.provinceArr = [&amp;ldquo;江苏&amp;rdquo;, &amp;ldquo;云南&amp;rdquo;];
    $scope.cityArr = [];&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$scope.$watch(&amp;quot;selectedProvince&amp;quot;, function(province) {
    // 真正有用的代码在这里，实际场景中这里可以是调用后端服务查询的关联数据
    switch (province) {
        case &amp;quot;江苏&amp;quot;: {
            $scope.cityArr = [&amp;quot;南京&amp;quot;, &amp;quot;苏州&amp;quot;];
            break;
        }
        case &amp;quot;云南&amp;quot;: {
            $scope.cityArr = [&amp;quot;昆明&amp;quot;, &amp;quot;丽江&amp;quot;];
            break;
        }
    }
});

$scope.selectProvince = function(province) {
    $scope.selectedProvince = province;
};

$scope.selectCity = function(city) {
    $scope.selectedCity = city;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
&lt;div ng-controller=&#34;RegionCtrl&#34;&gt;
    &lt;ul class=&#34;list-group&#34;&gt;
        &lt;li ng-repeat=&#34;province in provinceArr&#34; ng-class=&#34;{true:&#39;list-group-item active&#39;, false: &#39;list-group-item&#39;}[province==selectedProvince]&#34; ng-click=&#34;selectProvince(province)&#34;&gt;
            {{province}}
        &lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul class=&#34;list-group&#34;&gt;
        &lt;li ng-repeat=&#34;city in cityArr&#34; ng-class=&#34;{true:&#39;list-group-item active&#39;, false: &#39;list-group-item&#39;}[city==selectedCity]&#34; ng-click=&#34;selectCity(city)&#34;&gt;
            {{city}}
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
这段代码看起来比刚才复杂一些，其实有价值的代码就那个$watch里面的东西。这是什么意思呢？意思是，监控selectedProvince这个变量，只要它改变了，就去查询它可能造成的更新数据，然后剩下的事情就不用我们管了。&lt;/p&gt;

&lt;p&gt;如果是绑定到下拉框上，代码更简单，因为AngularJS专门作了这种考虑，ng-options就是这样的设置：&lt;/p&gt;

&lt;p&gt;&lt;select class=&#34;form-control col-md-6&#34; ng-model=&#34;selectedProvince&#34; ng-options=&#34;province for province in provinceArr&#34;&gt;&lt;/select&gt;
&lt;select class=&#34;form-control col-md-6&#34; ng-model=&#34;selectedCity&#34; ng-options=&#34;city for city in cityArr&#34;&gt;&lt;/select&gt;
从这个例子我们看到，相比于传统前端开发方式那种手动监听事件，手动更新DOM的方式，使用数据绑定做数据联动简直太容易了。如果要把这个例子改造成三级联动，只需对selectedCity也做一个监控就行了。&lt;/p&gt;

&lt;p&gt;一个综合的例子&lt;/p&gt;

&lt;p&gt;了解了这些细节之后，我们可以把它们结合起来做一个比较实际的综合例子。假设我们在为一家小店创建雇员的管理界面，其中包含一个雇员表格，以及一个可用于添加或编辑雇员的表单。&lt;/p&gt;

&lt;p&gt;雇员包含如下字段：姓名，年龄，性别，出生地，民族。其中，姓名通过输入框输入字符串，年龄通过输入框输入整数，性别通过点选单选按钮来选择，出生地用两个下拉框选择省份和城市，民族可以选择汉族和少数民族，如果选择了少数民族，可以手动输入民族名称。&lt;/p&gt;

&lt;p&gt;这个例子恰好能把我们刚才讲的绑定全部用到。我们先来看看有哪些绑定关系：&lt;/p&gt;

&lt;p&gt;雇员表格可以选中某行，该行样式会高亮
如果选中了某行，其详细数据将会同步到表单上
如果点击过新增或修改按钮，当前界面处于编辑中，则表单可输入，否则表单只读
修改和删除按钮的可点击状态，取决于表格中是否有选中的行
出生地点的省市下拉框存在联动关系
民族名称的输入框，其可见性取决于选择了汉族还是少数民族的单选按钮
新增修改删除、确定取消，这两组按钮互斥，永远不同时出现，其可见性取决于当前是否正在编辑。
确定按钮的可点击状态，取决于当前表单数据是否合法
如果想做得精细，还有更多可以使用绑定的地方，不过上面这些已经足够我们把所有知识用一遍了。&lt;/p&gt;

&lt;p&gt;这个例子的代码就不贴了，可以自行查看。&lt;/p&gt;

&lt;p&gt;数据绑定的拓展运用&lt;/p&gt;

&lt;p&gt;现在我们学会了数据绑定，可以借助这种特性，完成一些很别致的功能。比如说，如果想在页面上用div模拟一个正弦波，只需要把波形数据生成出来，然后一个绑定就可以完成了。&lt;/p&gt;

&lt;p&gt;$scope.staticItems = [];&lt;/p&gt;

&lt;p&gt;for (var i=0; i&amp;lt;720; i++) {
    $scope.staticItems.push(Math.ceil(100 * (1 + Math.sin(i * Math.PI / 180))));
}
如果我们想让这个波形动起来，也很容易，只需要结合一个定时器，动态生成这个波形数据就可以了。为了形成滚动效果，当波形采点数目超过某个值的时候，可以把最初的点逐个拿掉，保持总的数组长度。&lt;/p&gt;

&lt;p&gt;$scope.dynamicItems = [];&lt;/p&gt;

&lt;p&gt;var counter = 0;&lt;/p&gt;

&lt;p&gt;function addItem() {
    var newItem = Math.ceil(100 * (1 + Math.sin((counter++) * Math.PI / 180)));&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ($scope.dynamicItems.length &amp;gt; 500) {
    $scope.dynamicItems.splice(0, 1);
}

$scope.dynamicItems.push(newItem);

$timeout(function () {
    addItem();
}, 10);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;addItem();
这个例子对应的HTML代码如下：&lt;/p&gt;

&lt;p&gt;&lt;div ng-controller=&#34;WaveCtrl&#34;&gt;
    &lt;style&gt;
        .wave-item {
            float: left;
            width: 1px;
            background-color: #ffab51;
        }
    &lt;/style&gt;
    &lt;div&gt;
        &lt;div ng-repeat=&#34;item in staticItems track by $index&#34; class=&#34;wave-item&#34; ng-style=&#34;{&#39;height&#39;: item+&#39;px&#39;}&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div style=&#34;clear: left&#34;&gt;
        &lt;div ng-repeat=&#34;item in dynamicItems track by $index&#34; class=&#34;wave-item&#34; ng-style=&#34;{&#39;height&#39;: item+&#39;px&#39;}&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
有时候我们经常看到一些算法可视化的项目，比如把排序算法用可视化的方式展现出来，如果使用AngularJS的数据绑定，实现这种效果可谓易如反掌：&lt;/p&gt;

&lt;p&gt;&lt;div ng-controller=&#34;SortCtrl&#34;&gt;
    &lt;style&gt;
        .data-item {
            float: left;
            width: 20px;
            background-color: #c0c0c0;
            border: 1px solid #080808;
        }
    &lt;/style&gt;
    &lt;button ng-click=&#34;sort()&#34;&gt;Sort&lt;/button&gt;
    &lt;div&gt;
        &lt;div ng-repeat=&#34;item in arr track by $index&#34; class=&#34;data-item&#34; ng-style=&#34;{&#39;height&#39;: item*5+&#39;px&#39;}&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
$scope.arr = [2, 4, 5, 63, 4, 5, 55, 2, 4, 43];&lt;/p&gt;

&lt;p&gt;$scope.sort = function () {
    if (!sort($scope.arr)) {
        $timeout(function() {
            $scope.sort();
        }, 500);
    }
};&lt;/p&gt;

&lt;p&gt;function sort(array) {
    // 喵的，写到这个才发现yield是多么好啊
    for (var i = 0; i &amp;lt; array.length; i++) {
        for (var j = array.length; j &amp;gt; 0; j&amp;ndash;) {
            if (array[j] &amp;lt; array[j - 1]) {
                var temp = array[j - 1];
                array[j - 1] = array[j];
                array[j] = temp;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            return false;
        }
    }
}

return true;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
看，就这么简单，一个冒泡排序算法的可视化过程就写好啦。&lt;/p&gt;

&lt;p&gt;甚至，AngularJS还允许我们在SVG中使用数据绑定，使用它，做一些小游戏也是很容易的，比如我写了个双人对战的象棋，这里有演示地址，可以查看源码，是不是很简单？&lt;/p&gt;

&lt;p&gt;小结&lt;/p&gt;

&lt;p&gt;刚才我们已经看到数据绑定的各种使用场景了，这个东西带给我们的最大好处是什么呢？我们回顾一下之前写Web界面，有一部分时间在写HTML和CSS，一部分时间在写纯逻辑的JavaScript，还有很多时间在把这两者结合起来，比如各种创建或选取DOM，设置属性，添加等等，这些事情都是很机械而繁琐的，数据绑定把这个过程简化了，代码也跟着清晰了。&lt;/p&gt;

&lt;p&gt;数据绑定是一种思维方式，一切的核心就是数据。数据的变更导致界面的更新，如果我们想要更新界面，只需改变数据即可。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>angular模块机制</title>
      <link>https://satisfied1.github.io/post/angular%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Thu, 08 Dec 2016 11:05:22 +0800</pubDate>
      
      <guid>https://satisfied1.github.io/post/angular%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6/</guid>
      <description>&lt;p&gt;Angular中的模块机制&lt;/p&gt;

&lt;p&gt;module&lt;/p&gt;

&lt;p&gt;在AngularJS中，有module的概念，但是它这个module，跟我们通常在AMD里面看到的module是完全不同的两种东西，大致可以相当于是一个namespace，或者package，表示的是一堆功能单元的集合。&lt;/p&gt;

&lt;p&gt;一个比较正式的Angular应用，需要声明一个module，供初始化之用。比如说：&lt;/p&gt;

&lt;p&gt;angular.module(&amp;ldquo;test&amp;rdquo;, [])
        .controller(&amp;ldquo;TestCtrl&amp;rdquo;, [&amp;ldquo;$scope&amp;rdquo;, function($scope) {
            $scope.a = 1;
        }]);
随后，可以在HTML中指定这个module：&lt;/p&gt;

&lt;div ng-app=&#34;test&#34; ng-controller=&#34;TestCtrl&#34;&gt;
    {{a}}
&lt;/div&gt;
这样，就是以这个div为基准容器，实例化了刚才定义的module。

或者，也可以等价地这样，在这里，我们很清楚地看到，module的意义是用于标识在一个页面中可能包含的多个Angular应用。

angular.element(document).ready(function() {
    angular.bootstrap(document.getElementById(&#34;app1&#34;), [&#34;test&#34;]);
    angular.bootstrap(document.getElementById(&#34;app2&#34;), [&#34;test&#34;]);
});
&lt;div id=&#34;app1&#34; ng-controller=&#34;TestCtrl&#34;&gt;
    {{a}}
&lt;/div&gt;
&lt;div id=&#34;app2&#34; ng-controller=&#34;TestCtrl&#34;&gt;
    {{a}}
&lt;/div&gt;
这样可以在同一个页面中创建同一module的不同实例。两个应用互不干涉，在各自的容器中运行。

module的依赖项

除此之外，我们可以看到，在module声明的时候，后面带一个数组，这个数组里面可以指定它所依赖的module。比如说：

angular.module(&#34;moduleB&#34;, [])
        .service(&#34;GreetService&#34;, function() {
            return {
                greet: function() {
                    return &#34;Hello, world&#34;;
                }
            };
        });

angular.module(&#34;moduleA&#34;, [&#34;moduleB&#34;])
        .controller(&#34;TestCtrl&#34;, [&#34;$scope&#34;, &#34;GreetService&#34;, function($scope, GreetService) {
            $scope.words = &#34;&#34;;
            $scope.greet = function() {
                $scope.words = GreetService.greet();
            };
        }]);
然后对应的HTML是：

&lt;div ng-app=&#34;moduleA&#34;&gt;
    &lt;div ng-controller=&#34;TestCtrl&#34;&gt;
        &lt;span ng-bind=&#34;words&#34;&gt;&lt;/span&gt;
        &lt;button ng-click=&#34;greet()&#34;&gt;Greet&lt;/button&gt;
    &lt;/div&gt;
&lt;/div&gt;
好了，注意到这个例子里面，创建了两个module，在页面上只直接初始化了moduleA，但是从moduleA的依赖关系中，引用到了moduleB，所以，moduleA下面的TestCtrl，可以像引用同一个module下其他service那样，引用moduleB中定义的service。

到这里，我们是不是就可以把module当作一种namespace那样的组织方式呢，很可惜，它远远没有想的那么好。

这种module真的有用吗？

看下面这个例子：

angular.module(&#34;moduleA&#34;, [])
        .factory(&#34;A&#34;, function() {
            return &#34;a&#34;;
        })
        .factory(&#34;B&#34;, function() {
            return &#34;b&#34;;
        });

angular.module(&#34;moduleB&#34;, [])
        .factory(&#34;A&#34;, function() {
            return &#34;A&#34;;
        })
        .factory(&#34;B&#34;, function() {
            return &#34;B&#34;;
        });

angular.module(&#34;moduleC&#34;, [&#34;moduleA&#34;, &#34;moduleB&#34;])
        .factory(&#34;C&#34;, [&#34;A&#34;, &#34;B&#34;, function(A, B) {
            return A + B;
        }])
        .controller(&#34;TestCtrl&#34;, [&#34;$scope&#34;, &#34;C&#34;, function($scope, C) {
            $scope.c = C;
        }]);

angular.module(&#34;moduleD&#34;, [&#34;moduleB&#34;, &#34;moduleA&#34;])
        .factory(&#34;C&#34;, [&#34;A&#34;, &#34;B&#34;, function(A, B) {
            return A + B;
        }])
        .controller(&#34;TestCtrl&#34;, [&#34;$scope&#34;, &#34;C&#34;, function($scope, C) {
            $scope.c = C;
        }]);

angular.module(&#34;moduleE&#34;, [&#34;moduleA&#34;])
        .factory(&#34;A&#34;, function() {
            return &#34;AAAAA&#34;;
        })
        .factory(&#34;C&#34;, [&#34;A&#34;, &#34;B&#34;, function(A, B) {
            return A + B;
        }])
        .controller(&#34;TestCtrl&#34;, [&#34;$scope&#34;, &#34;C&#34;, function($scope, C) {
            $scope.c = C;
        }]);
&lt;div id=&#34;app1&#34; ng-controller=&#34;TestCtrl&#34;&gt;
    &lt;span ng-bind=&#34;c&#34;&gt;&lt;/span&gt;
&lt;/div&gt;

&lt;div id=&#34;app2&#34; ng-controller=&#34;TestCtrl&#34;&gt;
    &lt;span ng-bind=&#34;c&#34;&gt;&lt;/span&gt;
&lt;/div&gt;

&lt;p&gt;&lt;div id=&#34;app3&#34; ng-controller=&#34;TestCtrl&#34;&gt;
    &lt;span ng-bind=&#34;c&#34;&gt;&lt;/span&gt;
&lt;/div&gt;
angular.element(document).ready(function() {
    angular.bootstrap(document.getElementById(&amp;ldquo;app1&amp;rdquo;), [&amp;ldquo;moduleC&amp;rdquo;]);
    angular.bootstrap(document.getElementById(&amp;ldquo;app2&amp;rdquo;), [&amp;ldquo;moduleD&amp;rdquo;]);
    angular.bootstrap(document.getElementById(&amp;ldquo;app3&amp;rdquo;), [&amp;ldquo;moduleE&amp;rdquo;]);
});
我们在moduleA和moduleB中，分别定义了两个A跟B，然后，在moduleC和moduleD的时候中，分别依赖这两个module，但是依赖的顺序不同，其他所有代码完全一致，再看看结果，会发现两边的结果居然是不一致的。&lt;/p&gt;

&lt;p&gt;再看看moduleE，它自己里面有一个A，然后结果跟前两个例子也是不同的。&lt;/p&gt;

&lt;p&gt;照理说，我们对module会有一种预期，也就是把它当作命名空间来使用，但实际上它并未起到这种作用，只是一个简单的复制，把依赖的module中定义的东西全部复制到自己里面了，后面进来的会覆盖前面的，比如：&lt;/p&gt;

&lt;p&gt;moduleC里面，来自moduleA的两个变量被来自moduleB的覆盖了
moduleD里面，来自moduleB的两个变量被来自moduleA的覆盖了
moduleE里面，来自moduleA的A被moduleE自己里面的A覆盖了，因为它的A是后加进来的
整个覆盖过程没有任何提示。&lt;/p&gt;

&lt;p&gt;我们可以把module设计的初衷理解为：供不同的开发团队，或者不同的业务模块做归类约束用，但实际上完全没有起到这种作用。结果，不得不在下级组织单元的命名上继续做文章，不然在多项目集成的时候，就要面临冲突的风险。&lt;/p&gt;

&lt;p&gt;更多的坑&lt;/p&gt;

&lt;p&gt;不仅如此，这种module机制还为大型应用造成了不必要的麻烦。比如说，module不支持运行时添加依赖，看下面的例子：&lt;/p&gt;

&lt;p&gt;angular.module(&amp;ldquo;some.components&amp;rdquo;, [])
    //这里定义了一些组件
    ;
假设上面是一个组件库，集中存放于components.js中，我们要在自己的应用中使用，必须：&lt;/p&gt;

&lt;p&gt;angular.module(&amp;ldquo;our.app&amp;rdquo;, [&amp;ldquo;some.components&amp;rdquo;]);
现在假设这个components.js较大，我们不打算在首页引入，想在某个时候动态加载，就会出现这样的尴尬局面：&lt;/p&gt;

&lt;p&gt;主应用our.app启动的时候，必须声明所有依赖项
但是它所依赖的module &amp;ldquo;some.components&amp;rdquo;的声明还在另外一个未加载的文件components.js中
关键问题就在于它不存在一个在our.app启动之后向其中添加some.components依赖的方式。我们预期的代码方式是类似这样：&lt;/p&gt;

&lt;p&gt;angular.module(&amp;ldquo;our.app&amp;rdquo;, []);&lt;/p&gt;

&lt;p&gt;require(&amp;ldquo;components.js&amp;rdquo;, function() {
    // angular.module(&amp;ldquo;our.app&amp;rdquo;).addDependency(&amp;ldquo;some.components&amp;rdquo;);
    // ready to use&lt;br /&gt;
});
也就是这段代码中注释掉的那句。但从现在看来，它基本没法做这个，因为他用的是复制的方式，而且对同名的业务单元不做提示，也就是可能出现覆盖了已经在使用的模块，导致同一个应用中的同名业务单元出现行为不一致的情况，对排错很不利。&lt;/p&gt;

&lt;p&gt;在一些angular最佳实践中，建议各业务模块使用module来组织业务单元，基于以上原因，我个人是不认同的，我推荐在下一级的controller，service，factory等东西上，使用标准AMD的那种方式定义名称，而彻底放弃module的声明，比如所有业务代码都适用同一个module。详细的介绍，我会在另外一篇文章中给出。&lt;/p&gt;

&lt;p&gt;此外，考虑到在前端体系中，JavaScript是需要加载到浏览器才能使用的，module的机制自身也至少应当包括异步加载机制，很可惜，没有。没有模块加载机制，意味着什么呢？意味着做大型应用有麻烦。这个可以用一些变通的方式去处理，在这里先不提了。&lt;/p&gt;

&lt;p&gt;可以看到，Angular中的module并未起到预期作用，相反，还造成了一些麻烦。因此，我认为这是Angular当前版本中唯一一块弊大于利的东西，在2.0中，这部分已经做了重新规划，会把这些问题解决，也加入动态加载的考虑。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>angular视图模型层次</title>
      <link>https://satisfied1.github.io/post/angular%E8%A7%86%E5%9B%BE%E6%A8%A1%E5%9E%8B%E5%B1%82%E6%AC%A1/</link>
      <pubDate>Thu, 08 Dec 2016 11:04:43 +0800</pubDate>
      
      <guid>https://satisfied1.github.io/post/angular%E8%A7%86%E5%9B%BE%E6%A8%A1%E5%9E%8B%E5%B1%82%E6%AC%A1/</guid>
      <description>&lt;p&gt;视图模型的层次&lt;/p&gt;

&lt;p&gt;嵌套作用域的数据继承&lt;/p&gt;

&lt;p&gt;在Angular中，存在作用域的继承。所谓作用域的继承，是指：如果两个视图有包含关系，内层视图对应的作用域可以共享外层视图作用域的数据。比如说：&lt;/p&gt;

&lt;p&gt;&lt;body ng-app=&#34;test&#34;&gt;
    &lt;div ng-controller=&#34;OuterCtrl&#34;&gt;
        &lt;span ng-bind=&#34;a&#34;&gt;&lt;/span&gt;
        &lt;div ng-controller=&#34;InnerCtrl&#34;&gt;
            &lt;span ng-bind=&#34;a&#34;&gt;&lt;/span&gt;
            &lt;span ng-bind=&#34;b&#34;&gt;&lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
var app = angular.module(&amp;ldquo;test&amp;rdquo;, []);&lt;/p&gt;

&lt;p&gt;app.controller(&amp;ldquo;OuterCtrl&amp;rdquo;, function ($scope) {
    $scope.a = 1;
});&lt;/p&gt;

&lt;p&gt;app.controller(&amp;ldquo;InnerCtrl&amp;rdquo;, function ($scope) {
    $scope.b = 100;
});
内层的这个div上，一样也可以绑定变量a，因为在Angular内部，InnerCtrl的实例的原型会被设置为OuterCtrl的实例。&lt;/p&gt;

&lt;p&gt;我们改变一下这个示例，如果在内层作用域上，对a进行赋值会怎样？&lt;/p&gt;

&lt;p&gt;&lt;body ng-app=&#34;test&#34;&gt;
    &lt;div ng-controller=&#34;OuterCtrl&#34;&gt;
        &lt;span ng-bind=&#34;a&#34;&gt;&lt;/span&gt;
        &lt;div ng-controller=&#34;InnerCtrl&#34;&gt;
            &lt;span ng-bind=&#34;a&#34;&gt;&lt;/span&gt;
            &lt;span ng-bind=&#34;b&#34;&gt;&lt;/span&gt;
            &lt;button ng-click=&#34;increasea()&#34;&gt;increase a&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
var app = angular.module(&amp;ldquo;test&amp;rdquo;, []);&lt;/p&gt;

&lt;p&gt;app.controller(&amp;ldquo;OuterCtrl&amp;rdquo;, function ($scope) {
    $scope.a = 1;
});&lt;/p&gt;

&lt;p&gt;app.controller(&amp;ldquo;InnerCtrl&amp;rdquo;, function ($scope) {
    $scope.b = 100;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$scope.increasea = function() {
    $scope.a++;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;});
点击这个按钮的时候，发现了一个问题，内层有了a，而且值在增加，外层的不变了。这是为什么呢？&lt;/p&gt;

&lt;p&gt;因为它其实是通过原型集成来做到这样的。像上面这样的包含关系，内层scope的prototype被自动设置为外层的scope了，所以，才可以在内层使用这个a。这时候在内层给a赋值，当然就赋到它自己上了，不会赋值到原型的那个对象上。&lt;/p&gt;

&lt;p&gt;同理，如果内外两层作用域上存在同名变量，在内层界面赋值的时候只会赋到内层作用域上的那个变量，不会影响到外层的。&lt;/p&gt;

&lt;p&gt;那么，除了显式的ng-controller，Angular还会在什么地方引入视图模型的继承呢，主要是这些：&lt;/p&gt;

&lt;p&gt;数组和对象属性的迭代&lt;/p&gt;

&lt;p&gt;在Angular里面，有ng-repeat指令，可以用于遍历数组元素、对象属性。&lt;/p&gt;

&lt;p&gt;&lt;ul&gt;
    &lt;li ng-repeat=&#34;member in members&#34;&gt;{{member.name}}&lt;/li&gt;
&lt;/ul&gt;
单从这个片段看，看不出视图继承的意义。我们把这个例子再拓展一下：&lt;/p&gt;

&lt;p&gt;&lt;ul&gt;
    &lt;li ng-repeat=&#34;member in members&#34;&gt;{{member.name}} in {{teamname}}&lt;/li&gt;
&lt;/ul&gt;
它对应的视图模型是这么个结构：&lt;/p&gt;

&lt;p&gt;function TeamCtrl($scope) {
    $scope.teamname = &amp;ldquo;Disney&amp;rdquo;;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$scope.members = [
    {name: &amp;quot;Tom Cat&amp;quot;},
    {name: &amp;quot;Jerry Mouse&amp;quot;},
    {name: &amp;quot;Donald Duck&amp;quot;},
    {name: &amp;quot;Micky Mouse&amp;quot;}
];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
好了，注意到这里，teamname跟members里面的成员其实不在一层作用域，因为它给循环的每个元素都建立了单独的作用域，如果不允许视图模型的继承，在li里面是没法访问到teamname的。为了让这段话更容易理解，我作个转换：&lt;/p&gt;

&lt;p&gt;var teamname = &amp;ldquo;Disney&amp;rdquo;;
var members = [
    {name: &amp;ldquo;Tom Cat&amp;rdquo;},
    {name: &amp;ldquo;Jerry Mouse&amp;rdquo;},
    {name: &amp;ldquo;Donald Duck&amp;rdquo;},
    {name: &amp;ldquo;Micky Mouse&amp;rdquo;}
];&lt;/p&gt;

&lt;p&gt;for (var i=0; i&amp;lt;members.length; i++) {
    var member = members[i];
    console.log(member.name + &amp;ldquo; in &amp;rdquo; + teamname);
}
ng-repeat内部给每个循环造了个作用域，如果不这么做，各个member就无法区分开了。在这种情况下，如果没有作用域的继承关系，在循环内，就访问不到这个teamname。&lt;/p&gt;

&lt;p&gt;在这里，我觉得不一定非要造子作用域，它搞子作用域的原因无非是为了区分每个循环变量，但其实可以换一种写法，比如，avalon框架里的repeat写法就很好，在属性上指定循环元素变量名，然后给每个元素生成ObjectProxy，包装每个元素的数据，附带$index等有可能在循环过程中访问的东西。&lt;/p&gt;

&lt;p&gt;因此，这里其实不必出现Scope的新实例，而是用一个ObjectProxy返回元素数据即可。&lt;/p&gt;

&lt;p&gt;很可能我们的场景还有些简单，再来个复杂的：&lt;/p&gt;

&lt;p&gt;&lt;div ng-controller=&#34;TestCtrl&#34;&gt;
    &lt;div ng-repeat=&#34;boy in boys&#34;&gt;
        &lt;span style=&#34;color:red&#34; ng-bind=&#34;boy.name&#34;&gt;&lt;/span&gt;
        &lt;span style=&#34;color:green&#34; ng-bind=&#34;boy.age&#34;&gt;&lt;/span&gt;
        &lt;button ng-click=&#34;boy.growUP()&#34;&gt;grow up&lt;/button&gt;
    &lt;/div&gt;
&lt;/div&gt;
function TestCtrl($scope){
    $scope.boys = [{
        name: &amp;ldquo;Tom&amp;rdquo;,
        age: 5,
        growUP: function() {
            this.age ++;
        }
    }, {
        name: &amp;ldquo;Jerry&amp;rdquo;,
        age: 2,
        growUP: function() {
            this.age ++;
        }
    }];
}
这里，每个boy都能自增自己的年龄，原理与上面相同，这里面growUp方法的调用，用ObjectProxy应当也能处理。&lt;/p&gt;

&lt;p&gt;动态包含&lt;/p&gt;

&lt;p&gt;另外一个造成视图继承的原因是动态引入界面模板，比如说ng-include和ng-view等。&lt;/p&gt;

&lt;p&gt;inner.html&lt;/p&gt;

&lt;p&gt;&lt;div&gt;
    &lt;span ng-bind=&#34;name&#34;&gt;&lt;/span&gt;
&lt;/div&gt;
outer.html&lt;/p&gt;

&lt;p&gt;&lt;div ng-controller=&#34;OuterCtrl&#34;&gt;
    &lt;span ng-bind=&#34;name&#34;&gt;&lt;/span&gt;
    &lt;div ng-include=&#34;&#39;inner.html&#39;&#34;&gt;&lt;/div&gt;
&lt;/div&gt;
function OuterCtrl($scope) {
    $scope.name = &amp;ldquo;outer name&amp;rdquo;;
}
对上面这个例子来说，ng-include会创建一层作用域，如果不允许作用域继承，那么内层的HTML中就拿不到name属性。那么，为什么ng-include一定要创建子作用域呢？在这个例子里，创建子作用域并不一定必要，直接让两层HTML模板对应同一个视图模型的实例，不就可以了？&lt;/p&gt;

&lt;p&gt;我感觉他可能是为了省事，否则要判断动态include进来的这个HTML片段中，是否还指定了别的控制器，如果不管三七二十一就创建子作用域，这事就省了。ng-view跟ng-include的情况还不一样，因为ng-view可能会在路由里面指定新的控制器，所以判断起来就更复杂了，基本上只能创建新作用域。&lt;/p&gt;

&lt;p&gt;视图模型的继承好不好？&lt;/p&gt;

&lt;p&gt;视图模型的继承在很多情况下是很方便，但造成问题的可能性也会非常多。真的需要这样的共享机制吗？&lt;/p&gt;

&lt;p&gt;大家都知道，组件化是解决开发效率不高的银弹，但具体如何做组件化，人们的看法是五花八门的。Angular提供的控制器，服务，指令等概念，把不同的东西隔离到各自的地方，这是一种很好的组件化思路，但与此同时，界面模板层非常乱。&lt;/p&gt;

&lt;p&gt;我们可以理解它的用意：只把界面模板层当作配置文件来使用，压根就不考虑它的可复用性。是啊，反正只用一次，就算我写得乱，又怎样呢？可是在Angular中，界面模板是跟控制器密切相关的。我很怀疑控制器的可重用性，注意，它虽然叫控制器，但其实更应该算视图模型。&lt;/p&gt;

&lt;p&gt;从可重用性角度来看，如果满分5分的话，整个应用的这些部分的得分应当是这样：&lt;/p&gt;

&lt;p&gt;服务，比如说，对后端RESTful接口的AJAX调用，对本地存储的访问等，5分
控制器（也就是视图模型），2-3分
指令，这个要看情况，有的指令是当作对HTML元素体系的扩展来用的，有些是其他事情的
纯UI类型的指令，也可以算是控件，比如DatetimePicker，5分
有些用于沟通DOM跟视图模型的指令，2分
界面模板，这个基本就没有重用性了，1分
从这里我们可以看到，以可重用度来排序，最有价值的是服务和控件，服务代表着业务逻辑的基本单元，控件代表了UI层的最小单元，所以它们是最值得重用的。&lt;/p&gt;

&lt;p&gt;现在来看看中间层：视图模型值得重用吗？还是值得的。比如说，同一视图模型以不同的界面模板来展现，这就是一种很好的方式。如果说，同一个视图模型要支持多个界面模板，这些界面模板使用的模型字段或者方法有差异，也可以考虑在视图模型中取并集。例如：&lt;/p&gt;

&lt;p&gt;function TestCtrl($scope) {
    $scope.counter = 0;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$scope.increase = function() {
    $scope.counter++;
};

$scope.decrease = function() {
    $scope.counter--;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
1.html&lt;/p&gt;

&lt;p&gt;&lt;div ng-controller=&#34;TestCtrl&#34;&gt;
    &lt;span ng-bind=&#34;counter&#34;&gt;&lt;/span&gt;
    &lt;button ng-click=&#34;increase()&#34;&gt;increase&lt;/button&gt;
&lt;/div&gt;
2.html&lt;/p&gt;

&lt;p&gt;&lt;div ng-controller=&#34;TestCtrl&#34;&gt;
    &lt;span ng-bind=&#34;counter&#34;&gt;&lt;/span&gt;
    &lt;button ng-click=&#34;decrease()&#34;&gt;decrease&lt;/button&gt;
&lt;/div&gt;
3.html&lt;/p&gt;

&lt;p&gt;&lt;div ng-controller=&#34;TestCtrl&#34;&gt;
    &lt;span ng-bind=&#34;counter&#34;&gt;&lt;/span&gt;
    &lt;button ng-click=&#34;increase()&#34;&gt;increase&lt;/button&gt;
    &lt;button ng-click=&#34;decrease()&#34;&gt;decrease&lt;/button&gt;
&lt;/div&gt;
三个视图的内容是有差异的，但它们仍然共用了同一个视图模型，这个视图模型的内容包含三个视图所能用到的所有属性和方法，每个视图各取所需，互不影响。&lt;/p&gt;

&lt;p&gt;这时候，我们再来看视图模型的继承会造成什么影响。如果是我们有了视图模型的继承关系，就意味着界面模板的包含关系必须跟视图模型的继承关系完全一致，这个很大程度上是增加了管理成本的，也造成了视图模型的非通用性。&lt;/p&gt;

&lt;p&gt;刚开始提到的例子，如果内外层有同名变量，要在内层作用域中显式变更外层的变量，需要从scope.$parent里面去赋值。而一旦在代码中写了$parent这样的东西，就意味着视图模型只能以这样的方式包含了，甚至说，如果不想变更它们的包含关系，只想变更包含层级，也是不可能的，那说不定就要变成$parent.$parent了。&lt;/p&gt;

&lt;p&gt;我们看个场景：&lt;/p&gt;

&lt;p&gt;&lt;body ng-app=&#34;test&#34;&gt;
    &lt;div ng-controller=&#34;OuterCtrl&#34;&gt;
        &lt;span ng-bind=&#34;a&#34;&gt;&lt;/span&gt;
        &lt;div ng-controller=&#34;InnerCtrl&#34;&gt;
            &lt;span ng-bind=&#34;a&#34;&gt;&lt;/span&gt;
            &lt;button ng-click=&#34;increaseOuterA()&#34;&gt;increase outer a&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
var app = angular.module(&amp;ldquo;test&amp;rdquo;, []);&lt;/p&gt;

&lt;p&gt;app.controller(&amp;ldquo;OuterCtrl&amp;rdquo;, function ($scope) {
    $scope.a = 1;
});&lt;/p&gt;

&lt;p&gt;app.controller(&amp;ldquo;InnerCtrl&amp;rdquo;, function ($scope) {
    $scope.a = 100;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$scope.increaseOuterA = function() {
    $scope.$parent.a++;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;});
这里，因为在InnerCtrl中显式调用了$parent，所以它跟OuterCtrl的视图关系就只能非常固定了。如果说，我们这时候把里面这个div提取出来，放在单独的HTML文件中，然后使用ng-view或者ng-include引入它，因为它们本来就要创建一级作用域，所以会导致这个中间又隔了一级，$parent变成了$parent.$parent，非常不好。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;p&gt;&lt;body ng-app=&#34;test&#34;&gt;
    &lt;div ng-controller=&#34;OuterCtrl&#34;&gt;
        &lt;span ng-bind=&#34;a&#34;&gt;&lt;/span&gt;
        &lt;div ng-include=&#34;&#39;inner.html&#39;&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
inner.html&lt;/p&gt;

&lt;p&gt;&lt;div ng-controller=&#34;InnerCtrl&#34;&gt;
    &lt;span ng-bind=&#34;a&#34;&gt;&lt;/span&gt;
    &lt;button ng-click=&#34;increaseOuterA()&#34;&gt;increase outer a&lt;/button&gt;
&lt;/div&gt;
个人认为，在AngularJS中，视图模型的继承虽然使得很多时候代码写起来比较方便，但有些时候会造成很多麻烦。当编写视图模型代码的时候，应当尽量避免父子作用域存在同名变量的情况，以防止造成隐含的问题。不了解AngularJS实现原理的朋友很可能在这里踩很多坑。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Angular数据绑定</title>
      <link>https://satisfied1.github.io/post/Angular%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</link>
      <pubDate>Thu, 08 Dec 2016 11:03:20 +0800</pubDate>
      
      <guid>https://satisfied1.github.io/post/Angular%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</guid>
      <description>&lt;p&gt;Angular沉思录&lt;/p&gt;

&lt;p&gt;接触AngularJS已经两年多了，时常问自己一些问题，如果是我实现它，会在哪些方面选择跟它相同的道路，哪些方面不同。为此，记录了一些思考，给自己回顾，也供他人参考。&lt;/p&gt;

&lt;p&gt;初步大致有以下几个方面：&lt;/p&gt;

&lt;p&gt;数据双向绑定
视图模型的继承关系
模块和依赖注入的设计
待定
数据的双向绑定&lt;/p&gt;

&lt;p&gt;Angular实现了双向绑定机制。所谓的双向绑定，无非是从界面的操作能实时反映到数据，数据的变更能实时展现到界面。&lt;/p&gt;

&lt;p&gt;一个最简单的示例就是这样：&lt;/p&gt;

&lt;p&gt;&lt;div ng-controller=&#34;CounterCtrl&#34;&gt;
    &lt;span ng-bind=&#34;counter&#34;&gt;&lt;/span&gt;
    &lt;button ng-click=&#34;counter=counter+1&#34;&gt;increase&lt;/button&gt;
&lt;/div&gt;
function CounterCtrl($scope) {
    $scope.counter = 1;
}
这个例子很简单，毫无特别之处，每当点击一次按钮，界面上的数字就增加一。&lt;/p&gt;

&lt;p&gt;绑定数据是怎样生效的&lt;/p&gt;

&lt;p&gt;初学AngularJS的人可能会踩到这样的坑，假设有一个指令：&lt;/p&gt;

&lt;p&gt;var app = angular.module(&amp;ldquo;test&amp;rdquo;, []);&lt;/p&gt;

&lt;p&gt;app.directive(&amp;ldquo;myclick&amp;rdquo;, function() {
    return function (scope, element, attr) {
        element.on(&amp;ldquo;click&amp;rdquo;, function() {
            scope.counter++;
        });
    };
});&lt;/p&gt;

&lt;p&gt;app.controller(&amp;ldquo;CounterCtrl&amp;rdquo;, function($scope) {
    $scope.counter = 0;
});
&lt;body ng-app=&#34;test&#34;&gt;
    &lt;div ng-controller=&#34;CounterCtrl&#34;&gt;
        &lt;button myclick&gt;increase&lt;/button&gt;
        &lt;span ng-bind=&#34;counter&#34;&gt;&lt;/span&gt;
    &lt;/div&gt;
&lt;/body&gt;
这个时候，点击按钮，界面上的数字并不会增加。很多人会感到迷惑，因为他查看调试器，发现数据确实已经增加了，Angular不是双向绑定吗，为什么数据变化了，界面没有跟着刷新？&lt;/p&gt;

&lt;p&gt;试试在scope.counter++;这句之后加一句scope.digest();再看看是不是好了？&lt;/p&gt;

&lt;p&gt;为什么要这么做呢，什么情况下要这么做呢？我们发现第一个例子中并没有digest，而且，如果你写了digest，它还会抛出异常，说正在做其他的digest，这是怎么回事？&lt;/p&gt;

&lt;p&gt;我们先想想，假如没有AngularJS，我们想要自己实现这么个功能，应该怎样？&lt;/p&gt;

&lt;p&gt;&amp;lt;!DOCTYPE html&amp;gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&#34;utf-8&#34; /&gt;
        &lt;title&gt;two-way binding&lt;/title&gt;
    &lt;/head&gt;
    &lt;body onload=&#34;init()&#34;&gt;
        &lt;button ng-click=&#34;inc&#34;&gt;
            increase 1
        &lt;/button&gt;
        &lt;button ng-click=&#34;inc2&#34;&gt;
            increase 2
        &lt;/button&gt;
        &lt;span style=&#34;color:red&#34; ng-bind=&#34;counter&#34;&gt;&lt;/span&gt;
        &lt;span style=&#34;color:blue&#34; ng-bind=&#34;counter&#34;&gt;&lt;/span&gt;
        &lt;span style=&#34;color:green&#34; ng-bind=&#34;counter&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
        /* 数据模型区开始 */
        var counter = 0;

        function inc() {
            counter++;
        }

        function inc2() {
            counter+=2;
        }
        /* 数据模型区结束 */

        /* 绑定关系区开始 */
        function init() {
            bind();
        }

        function bind() {
            var list = document.querySelectorAll(&amp;quot;[ng-click]&amp;quot;);
            for (var i=0; i&amp;lt;list.length; i++) {
                list[i].onclick = (function(index) {
                    return function() {
                        window[list[index].getAttribute(&amp;quot;ng-click&amp;quot;)]();
                        apply();
                    };
                })(i);
            }
        }

        function apply() {
            var list = document.querySelectorAll(&amp;quot;[ng-bind=&#39;counter&#39;]&amp;quot;);
            for (var i=0; i&amp;lt;list.length; i++) {
                list[i].innerHTML = counter;
            }
        }
        /* 绑定关系区结束 */
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/html&gt;
可以看到，在这么一个简单的例子中，我们做了一些双向绑定的事情。从两个按钮的点击到数据的变更，这个很好理解，但我们没有直接使用DOM的onclick方法，而是搞了一个ng-click，然后在bind里面把这个ng-click对应的函数拿出来，绑定到onclick的事件处理函数中。为什么要这样呢？因为数据虽然变更了，但是还没有往界面上填充，我们需要在此做一些附加操作。&lt;/p&gt;

&lt;p&gt;从另外一个方面看，当数据变更的时候，需要把这个变更应用到界面上，也就是那三个span里。但由于Angular使用的是脏检测，意味着当改变数据之后，你自己要做一些事情来触发脏检测，然后再应用到这个数据对应的DOM元素上。问题就在于，怎样触发脏检测？什么时候触发？&lt;/p&gt;

&lt;p&gt;我们知道，一些基于setter的框架，它可以在给数据设值的时候，对DOM元素上的绑定变量作重新赋值。脏检测的机制没有这个阶段，它没有任何途径在数据变更之后立即得到通知，所以只能在每个事件入口中手动调用apply()，把数据的变更应用到界面上。在真正的Angular实现中，这里先进行脏检测，确定数据有变化了，然后才对界面设值。&lt;/p&gt;

&lt;p&gt;所以，我们在ng-click里面封装真正的click，最重要的作用是为了在之后追加一次apply()，把数据的变更应用到界面上去。&lt;/p&gt;

&lt;p&gt;那么，为什么在ng-click里面调用$digest的话，会报错呢？因为Angular的设计，同一时间只允许一个$digest运行，而ng-click这种内置指令已经触发了$digest，当前的还没有走完，所以就出错了。&lt;/p&gt;

&lt;p&gt;$digest和$apply&lt;/p&gt;

&lt;p&gt;在Angular中，有$apply和$digest两个函数，我们刚才是通过$digest来让这个数据应用到界面上。但这个时候，也可以不用$digest，而是使用$apply，效果是一样的，那么，它们的差异是什么呢？&lt;/p&gt;

&lt;p&gt;最直接的差异是，$apply可以带参数，它可以接受一个函数，然后在应用数据之后，调用这个函数。所以，一般在集成非Angular框架的代码时，可以把代码写在这个里面调用。&lt;/p&gt;

&lt;p&gt;var app = angular.module(&amp;ldquo;test&amp;rdquo;, []);&lt;/p&gt;

&lt;p&gt;app.directive(&amp;ldquo;myclick&amp;rdquo;, function() {
    return function (scope, element, attr) {
        element.on(&amp;ldquo;click&amp;rdquo;, function() {
            scope.counter++;
            scope.$apply(function() {
                scope.counter++;
            });
        });
    };
});&lt;/p&gt;

&lt;p&gt;app.controller(&amp;ldquo;CounterCtrl&amp;rdquo;, function($scope) {
    $scope.counter = 0;
});
除此之外，还有别的区别吗？&lt;/p&gt;

&lt;p&gt;在简单的数据模型中，这两者没有本质差别，但是当有层次结构的时候，就不一样了。考虑到有两层作用域，我们可以在父作用域上调用这两个函数，也可以在子作用域上调用，这个时候就能看到差别了。&lt;/p&gt;

&lt;p&gt;对于$digest来说，在父作用域和子作用域上调用是有差别的，但是，对于$apply来说，这两者一样。我们来构造一个特殊的示例：&lt;/p&gt;

&lt;p&gt;var app = angular.module(&amp;ldquo;test&amp;rdquo;, []);&lt;/p&gt;

&lt;p&gt;app.directive(&amp;ldquo;increasea&amp;rdquo;, function() {
    return function (scope, element, attr) {
        element.on(&amp;ldquo;click&amp;rdquo;, function() {
            scope.a++;
            scope.$digest();
        });
    };
});&lt;/p&gt;

&lt;p&gt;app.directive(&amp;ldquo;increaseb&amp;rdquo;, function() {
    return function (scope, element, attr) {
        element.on(&amp;ldquo;click&amp;rdquo;, function() {
            scope.b++;
            scope.$digest();    //这个换成$apply即可
        });
    };
});&lt;/p&gt;

&lt;p&gt;app.controller(&amp;ldquo;OuterCtrl&amp;rdquo;, [&amp;ldquo;$scope&amp;rdquo;, function($scope) {
    $scope.a = 1;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$scope.$watch(&amp;quot;a&amp;quot;, function(newVal) {
    console.log(&amp;quot;a:&amp;quot; + newVal);
});

$scope.$on(&amp;quot;test&amp;quot;, function(evt) {
    $scope.a++;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}]);&lt;/p&gt;

&lt;p&gt;app.controller(&amp;ldquo;InnerCtrl&amp;rdquo;, [&amp;ldquo;$scope&amp;rdquo;, function($scope) {
    $scope.b = 2;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$scope.$watch(&amp;quot;b&amp;quot;, function(newVal) {
    console.log(&amp;quot;b:&amp;quot; + newVal);
    $scope.$emit(&amp;quot;test&amp;quot;, newVal);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}]);
&lt;div ng-app=&#34;test&#34;&gt;
    &lt;div ng-controller=&#34;OuterCtrl&#34;&gt;
        &lt;div ng-controller=&#34;InnerCtrl&#34;&gt;
            &lt;button increaseb&gt;increase b&lt;/button&gt;
            &lt;span ng-bind=&#34;b&#34;&gt;&lt;/span&gt;
        &lt;/div&gt;
        &lt;button increasea&gt;increase a&lt;/button&gt;
        &lt;span ng-bind=&#34;a&#34;&gt;&lt;/span&gt;
    &lt;/div&gt;
&lt;/div&gt;
这时候，我们就能看出差别了，在increase b按钮上点击，这时候，a跟b的值其实都已经变化了，但是界面上的a没有更新，直到点击一次increase a，这时候刚才对a的累加才会一次更新上来。怎么解决这个问题呢？只需在increaseb这个指令的实现中，把$digest换成$apply即可。&lt;/p&gt;

&lt;p&gt;当调用$digest的时候，只触发当前作用域和它的子作用域上的监控，但是当调用$apply的时候，会触发作用域树上的所有监控。&lt;/p&gt;

&lt;p&gt;因此，从性能上讲，如果能确定自己作的这个数据变更所造成的影响范围，应当尽量调用$digest，只有当无法精确知道数据变更造成的影响范围时，才去用$apply，很暴力地遍历整个作用域树，调用其中所有的监控。&lt;/p&gt;

&lt;p&gt;从另外一个角度，我们也可以看到，为什么调用外部框架的时候，是推荐放在$apply中，因为只有这个地方才是对所有数据变更都应用的地方，如果用$digest，有可能临时丢失数据变更。&lt;/p&gt;

&lt;p&gt;脏检测的利弊&lt;/p&gt;

&lt;p&gt;很多人对Angular的脏检测机制感到不屑，推崇基于setter，getter的观测机制，在我看来，这只是同一个事情的不同实现方式，并没有谁完全胜过谁，两者是各有优劣的。&lt;/p&gt;

&lt;p&gt;大家都知道，在循环中批量添加DOM元素的时候，会推荐使用DocumentFragment，为什么呢，因为如果每次都对DOM产生变更，它都要修改DOM树的结构，性能影响大，如果我们能先在文档碎片中把DOM结构创建好，然后整体添加到主文档中，这个DOM树的变更就会一次完成，性能会提高很多。&lt;/p&gt;

&lt;p&gt;同理，在Angular框架里，考虑到这样的场景：&lt;/p&gt;

&lt;p&gt;function TestCtrl($scope) {
    $scope.numOfCheckedItems = 0;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var list = [];

for (var i=0; i&amp;lt;10000; i++) {
    list.push({
        index: i,
        checked: false
    });
}

$scope.list = list;

$scope.toggleChecked = function(flag) {
    for (var i=0; i&amp;lt;list.length; i++) {
        list[i].checked = flag;
        $scope.numOfCheckedItems++;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
如果界面上某个文本绑定这个numOfCheckedItems，会怎样？在脏检测的机制下，这个过程毫无压力，一次做完所有数据变更，然后整体应用到界面上。这时候，基于setter的机制就惨了，除非它也是像Angular这样把批量操作延时到一次更新，否则性能会更低。&lt;/p&gt;

&lt;p&gt;所以说，两种不同的监控方式，各有其优缺点，最好的办法是了解各自使用方式的差异，考虑出它们性能的差异所在，在不同的业务场景中，避开最容易造成性能瓶颈的用法。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>rem布局</title>
      <link>https://satisfied1.github.io/post/rem/</link>
      <pubDate>Wed, 07 Dec 2016 15:55:36 +0800</pubDate>
      
      <guid>https://satisfied1.github.io/post/rem/</guid>
      <description>&lt;p&gt;rem布局优点：等比例放大
rem布局缺点：大屏幕手机上看到元素还是一样多，违反设计原则&lt;/p&gt;

&lt;p&gt;rem布局实现方式：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;设计时 按照font-size:20px; 算出了所有的rem。
（可以设置成100，这样计算起来更方便）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;动态的计算出html font-size事件(document.documentElement.clientWidth /设计稿宽度)*20px;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于文字大小的处理 设置成px值&lt;/p&gt;

&lt;p&gt;响应式设计
小于400px  14px;
大于400px小于600px  16px;
大于600px   18px;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;字体样式：用手机默认字体&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;需要用CSS预编译实现rem布局
rem.scss中
$font-size:20;&lt;/p&gt;

&lt;p&gt;@function px2rem($px){
     @return $px / $font-size * 1rem;
}
index.scss中
@import &amp;ldquo;rem&amp;rdquo;;
div{
     width: px2rem(100);
)
index.html的head中
&lt;meta name=&#34;viewport&#34; content=&#34;width=device-width,initial-scale=1.0,user-scalable=no&#34;&gt;
&lt;script type=&#34;text/javascript&#34; src=&#39;lib/jquery.min.js&#39;&gt;&lt;/script&gt;//先引入jquery，否则下面的js代码用原生写
&lt;script type=&#34;text/javascript&#34;&gt;
           $(&amp;rdquo;[name=&amp;lsquo;viewport&amp;rsquo;]&amp;ldquo;).attr(&amp;ldquo;content&amp;rdquo;,&amp;ldquo;width=device-width,initial-scale=&amp;rdquo;+1/window.devicePixelRatio+&amp;ldquo;,user-scalable=no&amp;rdquo;);
          // 可布局的宽度 =  物理分辨率/window.devicePixelRatio/initial-scale
          //此处initial-scale设置会使可布局宽度=物理分辨率，可以根据设计稿大小直接写样式，更方便开发
&lt;/script&gt;
index.js中，根据屏幕宽度自动按比例更改字体大小
(function() {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var docEl = document.documentElement;
var resizeEvt = &#39;orientation&#39; in window ? &#39;orientationchange&#39; : &#39;resize&#39;;

// 在手机端有window.orientation属性,当前设备的屏幕方向，0表示竖屏，正负90表示横屏（向左与向右）模式
var recalc = function() {
        var clientWidth = docEl.clientWidth;

        if (!clientWidth) return;
        //20 ，是scss 定义的变量 就是计算rem的基准
        // 640 是设计图的宽度。
        docEl.style.fontSize = 20 * clientWidth / 640 + &#39;px&#39;;
};

if (!document.addEventListener) return;
window.addEventListener(resizeEvt, recalc, false);

//dom 节点加载完成后就会执行回调函数 DOMContentLoaded
//(img 图片 ，script加载完后 ， dom节点创建完 css，)window.onload
//$(function (){}) == $(document).ready(function(){})页面加载完(dom节点加载完)之后，就会执行这个参数function
document.addEventListener(&#39;DOMContentLoaded&#39;, recalc, false);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;})();&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>H5本地存储</title>
      <link>https://satisfied1.github.io/post/storage/</link>
      <pubDate>Wed, 07 Dec 2016 15:54:17 +0800</pubDate>
      
      <guid>https://satisfied1.github.io/post/storage/</guid>
      <description>&lt;p&gt;cookie的特点
- cookies 的大小限制在4KB
- cookies 是随HTTP 请求一起被发送的，因此会浪费一部分带宽
- 正确的操纵cookies 是很困难的
cookie用户凭证&lt;/p&gt;

&lt;p&gt;storage的特点
- 存储量限制 ( 5M )
- 客户端完成，不会请求服务器处理
- sessionStorage,localStorage&lt;/p&gt;

&lt;p&gt;storage API
     sessionStorage(会话存储)
          - session临时回话，从页面打开到页面关闭的时间段
          - 窗口的临时存储，页面关闭，本地存储消失
     localStorage
          - 永久存储（可以手动删除数据）
- setItem()
- 设置数据，key\value类型，类型都是字符串
- 可以用获取属性的形式操作
- getItem()
- 获取数据，通过key来获取到相应的value
- removeItem()
- 删除数据，通过key来删除相应的value
- clear():
- 删除全部存储的值
          &lt;h1&gt;localStorage&lt;/h1&gt;
          &lt;input type=&#34;text&#34;&gt;
          &lt;input type=&#34;button&#34; value=&#34;存&#34;&gt;
          &lt;input type=&#34;button&#34; value=&#34;取&#34;&gt;
          &lt;input type=&#34;button&#34; value=&#34;删&#34;&gt;
          &lt;iframe src=&#34;http://www.baidu.com&#34;&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      &amp;lt;script&amp;gt;
          var aInput = document.getElementsByTagName(&#39;input&#39;);

          aInput[1].onclick = function() {
               window.localStorage.setItem(&#39;name&#39;, aInput[0].value);
               window.localStorage.setItem(&#39;age&#39;, 30);
          };
          aInput[2].onclick = function() {
               alert(window.localStorage.getItem(&#39;name&#39;));
          };
          aInput[3].onclick = function() {
               //window.localStorage.removeItem(&#39;name&#39;);
               window.localStorage.clear(); //删除所有的stroge
          };
      &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;存储事件（storage事件）
- 当数据有修改或删除的情况下，就会触发storage事件
- 在对数据进行改变的窗口对象上是不会触发的，其他页面会触发
- Key : 修改或删除的key值，如果调用clear(),key为null
- oldValue :  原来设置的值
- newValue : 新设置的值，如果调用removeStorage(),key为null
- url : 触发该脚本变化的文档的url
          &lt;h1&gt;storage 事件&lt;/h1&gt;
          &lt;input type=&#34;text&#34;&gt;
          &lt;input type=&#34;button&#34; value=&#34;存&#34;&gt;
          &lt;input type=&#34;button&#34; value=&#34;取&#34;&gt;
          &lt;input type=&#34;button&#34; value=&#34;删&#34;&gt;
          &lt;script&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          var aInput = document.getElementsByTagName(&#39;input&#39;);

          aInput[1].onclick = function() {
               window.localStorage.setItem(&#39;name&#39;, aInput[0].value);
          };
          aInput[2].onclick = function() {
               alert(window.localStorage.getItem(&#39;name&#39;));
          };
          aInput[3].onclick = function() {
               window.localStorage.removeItem(&#39;name&#39;);
          };
          //当数据有修改或删除的情况下，就会触发storage事件
          //在对数据进行改变的窗口对象上是不会触发的
          window.addEventListener(&#39;storage&#39;, function(ev) {
               console.log(ev.key);
               console.log(ev.oldValue);
               console.log(ev.newValue);
               console.log(ev.storageArea);
               console.log(ev.url);
               alert(&amp;quot;已经修改storage&amp;quot;);
          }, false);
      &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应用缓存
什么是应用程序缓存（Application Cache）？
HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。
应用程序缓存为应用带来三个优势：
     离线浏览 - 用户可在应用离线时使用它们
     速度 - 已缓存资源加载得更快
     减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。
浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。
说明：
&lt;a href=&#34;http://www.w3school.com.cn/html5/html_5_app_cache.asp&#34;&gt;http://www.w3school.com.cn/html5/html_5_app_cache.asp&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>canvas</title>
      <link>https://satisfied1.github.io/post/canvas/</link>
      <pubDate>Wed, 07 Dec 2016 15:53:28 +0800</pubDate>
      
      <guid>https://satisfied1.github.io/post/canvas/</guid>
      <description>&lt;p&gt;canvas标签
（1）这个 HTML 元素是为了客户端矢量图形而设计的。它自己没有行为，但却把一个绘图 API 展现给客户端JavaScript 以使脚本能够把想绘制的东西都绘制到一块画布上。
（2）要从同一图形的一个 &lt;canvas&gt; 标记中移除元素，往往需要擦掉绘图重新绘制它。
          &lt;canvas id=&#34;c1&#34; width=&#34;400&#34; height=&#34;400&#34;&gt;
              你的浏览器不支持！
          &lt;!--默认有宽高 : width:300 height:150 。
          canvas的正确设置宽高 :属性 width=&#34;400&#34; height=&#34;400&#34; --&gt;
          &lt;/canvas&gt;&lt;/p&gt;

&lt;p&gt;绘制方块
获取绘制环境的方法      getContext(&amp;ldquo;2d&amp;rdquo;)
fillRect(L,T,W,H)
默认颜色是黑色      填充
strokeRect(L,T,W,H)
带边框的方块      默认一像素黑色边框
          &lt;script&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          var oC = document.getElementById(&amp;quot;c1&amp;quot;);

          //获取绘制2d 图像的环境。
          var oCanvas = oC.getContext(&amp;quot;2d&amp;quot;);


          oCanvas.fillRect(100,100,100,100);

          //左边距 上边距  ，矩形宽 和高。
          oCanvas.strokeRect(100,250,100,100);
      &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置绘图
fillStyle  :  填充颜色
lineWidth  :  线宽度，是一个数值
strokeStyle : 边线颜色
          &lt;script&gt;
              var oC = document.getElementById(&amp;lsquo;c1&amp;rsquo;);
              var oGC = oC.getContext(&amp;lsquo;2d&amp;rsquo;);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          oGC.fillStyle = &#39;yellow&#39;;
          oGC.fillRect(100,100,200,100);

          oGC.strokeStyle = &#39;blue&#39;;
          oGC.lineWidth = 10;
          oGC.strokeRect(100,250,100,100);

      &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;边界绘制
lineJoin:边界连接点样式     miter(默认) 、round(圆角)、bevel(斜角)
绘制线的图形，而不是填充的图形&lt;/p&gt;

&lt;p&gt;绘制路径
beginPath :  开始绘制路径
closePath  :  结束绘制路径（自动闭合相关路径） closePath()要在stroke 前调用
moveTo  :  确定绘制的起始点
lineTo  :  绘制路径到新的目标点
stroke  :  画线，默认黑色&lt;br /&gt;
fill  :  填充，默认黑色
clearRect  :   清除一个画布的矩形区域
              oGC.beginPath(); //开始绘制路径
              oGC.moveTo(100,100);  //设置一个初始点
              oGC.lineTo(200,200); //下一个目标点
              oGC.lineTo(200,300); //
              oGC.closePath();
              oGC.fill();  //填充颜色&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          oGC.beginPath();     //如果不新开这个路径，那么会将所有点连接起来
          oGC.moveTo(300,300);
          oGC.lineTo(300,350);
          oGC.lineTo(350,200);
          oGC.closePath();  //帮助闭合路径
          oGC.stroke(); //划线连接

          //清除画布某个区域
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//            oGC.clearRect(100,100,100,200);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          //清除整个画布区域
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//            oGC.clearRect(0,0,400,400);
save  : 保存路径
restore  :  恢复路径
例子   :&lt;br /&gt;
鼠标画线&lt;br /&gt;
          &lt;script&gt;
              var oC = document.getElementById(&amp;lsquo;c1&amp;rsquo;);
              var oGC = oC.getContext(&amp;lsquo;2d&amp;rsquo;);
              oGC.strokeStyle = &amp;ldquo;red&amp;rdquo;;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          //线帽
          oGC.lineCap = &amp;quot;round&amp;quot;;
          oGC.lineWidth = &amp;quot;10&amp;quot;;


          oC.onmousedown = function(ev){
               //确定划线的起始位置
               oGC.beginPath();
               oGC.moveTo(ev.clientX-oC.offsetLeft,ev.clientY-oC.offsetTop);
               oC.onmousemove = function(ev){
                    oGC.lineTo(ev.clientX-oC.offsetLeft,ev.clientY-oC.offsetTop);
                    oGC.stroke();
               }

               oC.onmouseup = function(){

                    oC.onmousemove = null;
                    oC.onmouseup = null;
               }
          }

      &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方块移动
canvas &amp;ldquo;动画效果 &amp;ldquo;， 边擦边画实现
&lt;canvas id=&#34;c1&#34; width=&#34;400&#34; height=&#34;400&#34; tabindex=&#34;0&#34;&gt;&lt;/canvas&gt;
&lt;script&gt;
              var oC = document.getElementById(&amp;lsquo;c1&amp;rsquo;);
              var oGC = oC.getContext(&amp;lsquo;2d&amp;rsquo;);
              oGC.fillStyle= &amp;ldquo;red&amp;rdquo;;
              oGC.fillRect(0, 0, 100, 100);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          var iNow = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//            setInterval(function(){
//                 oGC.clearRect(0,0,400,400);
//                 iNow++;
//                 oGC.fillRect(0, iNow, 100, 100);
//            },30);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          //canvas本身 不支持键盘事件。

          //支持键盘有两种方法：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//            (1)给window 绑定键盘&lt;/p&gt;

&lt;p&gt;//            (2)给canvas 加上一个tabindex 属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;           var isRightNow = 0;
          oC.onkeydown = function(ev){

               if(ev.keyCode==39){
                    oGC.clearRect(0,0,400,400);
                    isRightNow++;
                    oGC.fillRect(isRightNow,0,100,100);
               }else if(ev.keyCode==37){
                    oGC.clearRect(0,0,400,400);
                    isRightNow--;

                    oGC.fillRect(isRightNow,0,100,100);
               }
          }
      &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;绘制圆
- arc(x, y, 半径, 起始弧度, 结束弧度, 旋转方向)
- x , y : 起始位置
- 弧度与角度的关系：弧度 = 角度*Math.PI/180
- 旋转方向：默认 : 顺时针旋转 , 最后一个参数控制旋转方向 ：false顺时针，true就是逆时针&lt;/p&gt;

&lt;p&gt;插入图
- 等图片加载完，再执行canvas操作
- 图片预加载：直接在JS中可以载入一张图片，不需要写到html中。在onload中调用方法
          &lt;script&gt;
              var oC = document.getElementById(&amp;lsquo;c1&amp;rsquo;);
              var oGC = oC.getContext(&amp;lsquo;2d&amp;rsquo;);
              var yImg = new Image();
              yImg.onload = function() {
                   //参数个数 : 3个 5个 9个
                   //3参数 : 图片对象 , x坐标 , y坐标
                   //5参数 : 图片对象 , x坐标 , y坐标 , w宽 , h高
                   //9参数 : 图片对象 ,图片中的x坐标,图片中的y坐标,图片中的w宽,图片中的h高, canvas中的x坐标 , canvas中的y坐标 , canvas中的w宽               , canvas中的h高
                   //     oGC.drawImage(yImg,100,100,100,100);
                   oGC.drawImage(yImg,0,0,100,100,0,0,100,100);
              };
              yImg.src = &amp;lsquo;img/1.jpg&amp;rsquo;;
          &lt;/script&gt;&lt;/p&gt;

&lt;p&gt;设置背景
- createPattern(oImg,平铺方式)
- 2参为：repeat、repeat-x、repeat-y、no-repeat&lt;/p&gt;

&lt;p&gt;文本
- fillText(文字,x,y)
- font
- 文字大小 : &amp;ldquo;60px 微软雅黑&amp;rdquo;     两个属性都必须写
- textAlign
- 默认是start 跟left一样的效果 end right center
- textBaseline
- 文字上下的位置的方式 默认 : alphabetic  其他值top bottom middle hanging&lt;/p&gt;

&lt;p&gt;阴影
- shadowOffsetX、shadowOffsetY
- X轴偏移、Y轴偏移
- shadowBlur
- 高斯模糊值
- shadowColor
- 阴影颜色
          &lt;script&gt;
              var oC = document.getElementById(&amp;lsquo;c1&amp;rsquo;);
              var oGC = oC.getContext(&amp;lsquo;2d&amp;rsquo;);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          var str = &#39;宇宙第一天团&#39;;
          oGC.font = &#39;60px 微软雅黑&#39;; //大小和字体都写才会起作用
          oGC.textAlign = &amp;quot;left&amp;quot;;
          oGC.textBaseline = &amp;quot;hanging&amp;quot;;
          oGC.save();
          oGC.shadowOffsetX = 10; //默认阴影颜色 : 黑色透明 0 0 0 0
          oGC.shadowOffsetY = 10;
          oGC.shadowBlur = 10;
          oGC.shadowColor = &#39;red&#39;;

          oGC.fillText(str, 0, 0);
          oGC.restore();

          oGC.fillRect(100, 100, 100, 100);
      &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;像素-canvas中绘制的是位图(像素组成的)
- getImageData(x,y,w,h)
- 获取图像数据
- putImageData(获取图像,x,y)
- 设置新的图像数据
- 像素矩阵属性
- width height data
- createImageData(w,h)
- 生成新的像素矩阵，初始值是全透明的黑色，即(0,0,0,0)
oGC.globalAlpha 设置透明度
          &lt;script&gt;
              var oC = document.getElementById(&amp;lsquo;c1&amp;rsquo;);
              var oGC = oC.getContext(&amp;lsquo;2d&amp;rsquo;);
              var yImg = new Image();
              yImg.onload = function() {
                   oGC.drawImage(yImg,0,0,100,100,0,0,100,100);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;               var img = oGC.getImageData(0,0,100,100);
               for(var i =0;i&amp;lt;img.data.length;i+=4){
                    img.data[i+3]= &amp;quot;100&amp;quot;;
               }

               oGC.putImageData(img,100,100);
          };
          yImg.src = &#39;img/1.jpg&#39;;

      &amp;lt;/script&amp;gt;

      &amp;lt;script&amp;gt;
          var oC = document.getElementById(&#39;c1&#39;);
          var oGC = oC.getContext(&#39;2d&#39;);

          var img = oGC.createImageData(100,100);
          //console.log(img.data); 初始值是全透明的黑色，即(0,0,0,0)

          for(var i = 0; i &amp;lt; img.data.length; i += 4) {
               img.data[i + 3] = 255;
               img.data[i + 2] = 255;
          }

          oGC.putImageData(img, 100, 100);
      &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>AngularJS的工作原理</title>
      <link>https://satisfied1.github.io/post/AngularJS%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</link>
      <pubDate>Wed, 07 Dec 2016 15:39:19 +0800</pubDate>
      
      <guid>https://satisfied1.github.io/post/AngularJS%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</guid>
      <description>&lt;p&gt;HTML模板将会被浏览器解析到DOM中, DOM结构成为AngularJS编译器的输入。AngularJS将会遍历DOM模板, 来生成相应的NG指令,所有的指令都负责针对view(即HTML中的ng-model)来设置数据绑定。因此, NG框架是在DOM加载完成之后, 才开始起作用的.&lt;/p&gt;

&lt;p&gt;在html中:&lt;/p&gt;

&lt;p&gt;&lt;body ng-app=&#34;ngApp&#34;&gt;
    &lt;div ng-controller=&#34;ngCtl&#34;&gt;
        &lt;label ng-model=&#34;myLabel&#34;&gt;&lt;/label&gt;
        &lt;input type=&#34;text&#34; ng-model=&#34;myInput&#34; /&gt;
        &lt;button ng-model=&#34;myButton&#34; ng-click=&#34;btnClicked&#34;&gt;&lt;/button&gt;
    &lt;/div&gt;
&lt;/body&gt;
在js中:&lt;/p&gt;

&lt;p&gt;// angular app
var app = angular.module(&amp;ldquo;ngApp&amp;rdquo;, [], function(){
    console.log(&amp;ldquo;ng-app : ngApp&amp;rdquo;);
});
// angular controller
app.controller(&amp;ldquo;ngCtl&amp;rdquo;, [ &amp;lsquo;$scope&amp;rsquo;, function($scope){
    console.log(&amp;ldquo;ng-controller : ngCtl&amp;rdquo;);
    $scope.myLabel = &amp;ldquo;text for label&amp;rdquo;;
    $scope.myInput = &amp;ldquo;text for input&amp;rdquo;;
    $scope.btnClicked = function() {
        console.log(&amp;ldquo;Label is &amp;rdquo; + $scope.myLabel);
    }
}]);
如上,我们在html中先定义一个angular的app,指定一个angular的controller,则该controller会对应于一个作用域(可以用$scope前缀来指定作用域中的属性和方法等). 则在该ngCtl的作用域内的HTML标签, 其值或者操作都可以通过$scope的方式跟js中的属性和方法进行绑定.&lt;/p&gt;

&lt;p&gt;这样, 就实现了NG的双向数据绑定: 即HTML中呈现的view与AngularJS中的数据是一致的. 修改其一, 则对应的另一端也会相应地发生变化.&lt;/p&gt;

&lt;p&gt;这样的方式,使用起来真的非常方便. 我们仅关心HTML标签的样式, 及其对应在js中angular controller作用域下绑定的属性和方法. 仅此而已, 将众多复杂的DOM操作全都省略掉了.&lt;/p&gt;

&lt;p&gt;这样的思想,其实跟jQuery的DOM查询和操作是完全不一样的, 因此也有很多人建议用AngularJS的时候,不要混合使用jQuery. 当然, 二者各有优劣, 使用哪个就要看自己的选择了.&lt;/p&gt;

&lt;p&gt;NG中的app相当于一个模块module, 在每个app中可以定义多个controller, 每个controller都会有各自的作用域空间,不会相互干扰.&lt;/p&gt;

&lt;p&gt;看下边这段html:&lt;/p&gt;

&lt;p&gt;&lt;div ng-app=&#34;dataApp&#34;&gt;
    单价： &lt;input type=&#34;number&#34; min=0 ng-model=&#34;price&#34; ng-init=&#34;price = 299&#34;&gt;&lt;br&gt;
    数量： &lt;input type=&#34;number&#34; min=0 ng-model=&#34;quantity&#34; ng-init=&#34;quantity = 1&#34;&gt;&lt;br&gt;
    总价： {{ quantity * price }}
&lt;/div&gt;
你会惊喜地发现, 甚至不用写一行的JS代码, 即可完成计算并在界面展示结果.&lt;/p&gt;

&lt;p&gt;即: 在前端html中使用{{ }}括起来的变量, 是跟AngularJS中对应的controller作用域内的属性绑定在一起的. 实际上,{{}}等同于ng-bind指令, 即ng-bind=&amp;ldquo;myData&amp;rdquo;就能将NG中的myData数据跟前端对应元素绑定在一起.这样的话, 可以非常方便地做到从NG中获取任意数据并实时展示在页面上了.&lt;/p&gt;

&lt;p&gt;另外, $scope对象还提供了一个$apply方法, 用于进行html页面上的更新, 使用方式为:&lt;/p&gt;

&lt;p&gt;$scope.$apply(function(){
    $scope.myValue = &amp;ldquo;NewValue&amp;rdquo;;
});
$scope对象, 我们可以理解为NG框架中的一个作用域对象, 在该作用域内可以做到数据和视图的相互绑定, 同时又能与其他$scope对象的作用域隔离开来.&lt;/p&gt;

&lt;p&gt;当然, $scope也可以实现继承, 这部分内容在以后接触NG框架中其他对象的时候再分别做记录.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>